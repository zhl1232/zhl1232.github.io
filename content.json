{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"1047.删除字符串中的所有相邻重复项","text":"","content":""},{"title":"leetcode-961-重复N次的元素","text":"","content":""},{"title":"832.翻转图像","text":"","content":""},{"title":"811.子域名访问计数","text":"","content":""},{"title":"771.宝石与石头","text":"","content":""},{"title":"739.每日温度","text":"","content":""},{"title":"706.设计哈希映射","text":"","content":""},{"title":"705.设计哈希集合","text":"","content":""},{"title":"648.单词替换","text":"","content":""},{"title":"599.两个列表的最小索引总和","text":"","content":""},{"title":"535.TinyURL的加密与解密","text":"","content":""},{"title":"500.键盘行","text":"","content":""},{"title":"387.字符串中的第一个唯一字符","text":"","content":""},{"title":"350.两个数组的交集II","text":"","content":""},{"title":"349.两个数组的交集","text":"","content":""},{"title":"345.反转字符串中的元音字母","text":"","content":""},{"title":"344.反转字符串","text":"","content":""},{"title":"283.移动零","text":"","content":""},{"title":"219.存在重复元素II","text":"","content":""},{"title":"209.长度最小的子数组-二分方法未写","text":"","content":""},{"title":"205.同构字符串","text":"","content":""},{"title":"202.快乐数","text":"","content":""},{"title":"167.两数之和II-输入有序数组","text":"","content":""},{"title":"155.最小栈","text":"","content":""},{"title":"leetcode.125.验证回文串","text":"题目描述给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 说明：本题中，我们将空字符串定义为有效的回文串。 示例 1:12输入: &quot;A man, a plan, a canal: Panama&quot;输出: true 示例 2:12输入: &quot;race a car&quot;输出: false 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/valid-palindrome著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 标签 双指针 字符串 解题思路 处理字符串，只考虑字母和数字字符，忽略字母的大小写 用对撞指针，递归查看首尾是否一致即是否回文串解题方法1234567891011121314151617181920/** * @param &#123;string&#125; s * @return &#123;boolean&#125; */var isPalindrome = function(s) &#123; // s = s.replace(/[^\\w]/g, '').toLowerCase() // 题目要求只考虑字母和数字字符，所以上面的写法也没啥问题 s = s.replace(/[^0-9a-zA-Z]/g, '').toLowerCase() let left = 0; let right = s.length - 1; while(left &lt; right) &#123; if(s[left] != s[right]) &#123; return false &#125; left++ right-- &#125; return true&#125;;","content":"<h3 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h3><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p>\n<p>说明：本题中，我们将空字符串定义为有效的回文串。</p>\n<p>示例 1:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: &quot;A man, a plan, a canal: Panama&quot;</span><br><span class=\"line\">输出: true</span><br></pre></td></tr></table></figure></p>\n<p>示例 2:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: &quot;race a car&quot;</span><br><span class=\"line\">输出: false</span><br></pre></td></tr></table></figure></p>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/valid-palindrome\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/valid-palindrome</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<p>标签 <strong>双指针</strong> <strong>字符串</strong></p>\n<h3 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><ol>\n<li>处理字符串，只考虑字母和数字字符，忽略字母的大小写</li>\n<li>用对撞指针，递归查看首尾是否一致即是否回文串<h3 id=\"解题方法\"><a href=\"#解题方法\" class=\"headerlink\" title=\"解题方法\"></a>解题方法</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;string&#125;</span> <span class=\"variable\">s</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return <span class=\"type\">&#123;boolean&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> isPalindrome = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">s</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// s = s.replace(/[^\\w]/g, '').toLowerCase()</span></span><br><span class=\"line\">    <span class=\"comment\">// 题目要求只考虑字母和数字字符，所以上面的写法也没啥问题</span></span><br><span class=\"line\">    s = s.replace(<span class=\"regexp\">/[^0-9a-zA-Z]/g</span>, <span class=\"string\">''</span>).toLowerCase()</span><br><span class=\"line\">    <span class=\"keyword\">let</span> left = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> right = s.length - <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(left &lt; right) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s[left] != s[right]) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"literal\">false</span> </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        left++</span><br><span class=\"line\">        right--</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n</ol>\n"},{"title":"leetcode.118.杨辉三角","text":"题目描述给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。 在杨辉三角中，每个数是它左上方和右上方的数的和。 示例:123456789输入: 5输出:[ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/pascals-triangle著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 标签 数组 解题思路是在递归的卡片里看到的这题，所以先用递归解决了 终止条件，结果的 length 大于等于 numRows 返回值，每个二维数据的子数组 拆分的子问题，每个子数组的长度为当前行数，每个子数组里的值为它左上方和右上方的数的和，上方就是行数 - 1，左边就是当前子数组的值下标-1，右边就是下标+1，判断如果左上或者右上不存在，则为0 解题方法1234567891011121314151617181920212223var generate = function(numRows) &#123; let res = [] return sub(0, numRows, res)&#125;var sub = function(row, numRows, arr) &#123; let temp = [] if (row &lt; numRows) &#123; for (let i = 0; i &lt;= row; i++) &#123; if (row === 0) &#123; temp.push(1) &#125; else &#123; let left = i-1 &gt;= 0 ? arr[row-1][i-1] : 0 let right = i &lt; arr[row-1].length ? arr[row-1][i] : 0 temp.push(left+right) &#125; &#125; arr.push(temp) sub(++row, numRows, arr) return arr &#125;&#125;","content":"<h3 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h3><p>给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。</p>\n<p><img src=\"https://raw.githubusercontent.com/zhl1232/javascript-algorithm/master/static/img/118.gif\" alt=\"image\"></p>\n<p>在杨辉三角中，每个数是它左上方和右上方的数的和。</p>\n<p>示例:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: 5</span><br><span class=\"line\">输出:</span><br><span class=\"line\">[</span><br><span class=\"line\">     [1],</span><br><span class=\"line\">    [1,1],</span><br><span class=\"line\">   [1,2,1],</span><br><span class=\"line\">  [1,3,3,1],</span><br><span class=\"line\"> [1,4,6,4,1]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure></p>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/pascals-triangle\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/pascals-triangle</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<p>标签 <strong>数组</strong></p>\n<h3 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>是在递归的卡片里看到的这题，所以先用递归解决了</p>\n<ol>\n<li>终止条件，结果的 length 大于等于 numRows</li>\n<li>返回值，每个二维数据的子数组</li>\n<li>拆分的子问题，每个子数组的长度为当前行数，每个子数组里的值为它左上方和右上方的数的和，上方就是行数 - 1，左边就是当前子数组的值下标-1，右边就是下标+1，判断如果左上或者右上不存在，则为0</li>\n</ol>\n<h3 id=\"解题方法\"><a href=\"#解题方法\" class=\"headerlink\" title=\"解题方法\"></a>解题方法</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> generate = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">numRows</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = []</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> sub(<span class=\"number\">0</span>, numRows, res)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> sub = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">row, numRows, arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> temp = []</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (row &lt; numRows) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt;= row; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (row === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        temp.push(<span class=\"number\">1</span>)</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> left = i<span class=\"number\">-1</span> &gt;= <span class=\"number\">0</span> ? arr[row<span class=\"number\">-1</span>][i<span class=\"number\">-1</span>] : <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> right = i &lt; arr[row<span class=\"number\">-1</span>].length ? arr[row<span class=\"number\">-1</span>][i] : <span class=\"number\">0</span></span><br><span class=\"line\">        temp.push(left+right)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    arr.push(temp)</span><br><span class=\"line\">    sub(++row, numRows, arr)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"88.未完成，占坑","text":"题目描述给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。 说明:12初始化 nums1 和 nums2 的元素数量分别为 m 和 n。你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。 示例:12345输入:nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6], n = 3输出: [1,2,2,3,5,6] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/merge-sorted-array著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 标签 双指针 数组 解题思路解法一：唔。没学算法的解法。没啥用的。 时间复杂度较差，为O((n+m)log(n+m))123456789101112131415/** * @param &#123;number[]&#125; nums1 * @param &#123;number&#125; m * @param &#123;number[]&#125; nums2 * @param &#123;number&#125; n * @return &#123;void&#125; Do not return anything, modify nums1 in-place instead. */var merge = function(nums1, m, nums2, n) &#123; nums1.splice(m,nums1.length) nums2.splice(n,nums2.length) nums1.push(...nums2) nums1.sort((a,b) =&gt; &#123; return a - b &#125;)&#125;;","content":"<!--\n * @File: \n * @Author: 张宏亮 - zhl@xiaoniren.cn\n * @Date: 2019-08-18 15:46:12\n * @LastEditors: 张宏亮<hongliang@yunshan.net>\n * @LastEditTime: 2019-09-30 15:49:46\n * @Description: file content\n * @Versions: 1.0.0\n -->\n<h3 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h3><p>给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。</p>\n<p>说明:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">初始化 nums1 和 nums2 的元素数量分别为 m 和 n。</span><br><span class=\"line\">你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。</span><br></pre></td></tr></table></figure></p>\n<p>示例:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入:</span><br><span class=\"line\">nums1 = [1,2,3,0,0,0], m = 3</span><br><span class=\"line\">nums2 = [2,5,6],       n = 3</span><br><span class=\"line\"></span><br><span class=\"line\">输出: [1,2,2,3,5,6]</span><br></pre></td></tr></table></figure></p>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/merge-sorted-array\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/merge-sorted-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<p>标签 <strong>双指针</strong> <strong>数组</strong></p>\n<h3 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><h3 id=\"解法一：\"><a href=\"#解法一：\" class=\"headerlink\" title=\"解法一：\"></a>解法一：</h3><p>唔。没学算法的解法。没啥用的。</p>\n<p>时间复杂度较差，为O((n+m)log(n+m))<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;number[]&#125;</span> <span class=\"variable\">nums1</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;number&#125;</span> <span class=\"variable\">m</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;number[]&#125;</span> <span class=\"variable\">nums2</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;number&#125;</span> <span class=\"variable\">n</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return <span class=\"type\">&#123;void&#125;</span> </span>Do not return anything, modify nums1 in-place instead.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> merge = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">nums1, m, nums2, n</span>) </span>&#123;</span><br><span class=\"line\">    nums1.splice(m,nums1.length)</span><br><span class=\"line\">    nums2.splice(n,nums2.length)</span><br><span class=\"line\">    nums1.push(...nums2)</span><br><span class=\"line\">    nums1.sort(<span class=\"function\">(<span class=\"params\">a,b</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a - b</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"leetcode.80.删除排序数组中的重复项II","text":"题目描述给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例 1:12345给定 nums = [1,1,1,2,2,3],函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。你不需要考虑数组中超出新长度后面的元素。 示例 2:12345给定 nums = [0,0,1,1,1,1,2,3,3],函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。你不需要考虑数组中超出新长度后面的元素。 说明:123为什么返回数值是整数，但输出的答案是数组呢?请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下:12345678// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 标签 双指针 数组 解题思路原地算法，就是不依赖额外的资源或者依赖少数的额外资源，仅依靠输出来覆盖输入的一种算法操作。 在不复制数组的情况下从数组中删除元素的一些提示： 尝试双指针法。 你是否使用“元素顺序可以更改”这一属性？ 当要删除的元素很少时会发生什么？ 解法一：数组api定义 nums[0…i] 满足每个元素最多出现两次，遍历整个数列不断的维护这个定义。 1234567891011121314/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var removeDuplicates = function(nums) &#123; let i = 0 while (i &lt; nums.length) &#123; if (nums[i] === nums[i - 2]) &#123; nums.splice(i, 1) &#125; else &#123; i++ &#125; &#125;&#125;; 解法二：双指针维护两个指针， 慢指针 p1 初始为 0 ，快指针 p2 初始为 1 如果快指针的后一位 (p2 + 1) 和前一位( p1 )都相同，那说明该元素出现三次。 出现三次把快指针 p2 下元素原地删除，快指针不变，继续比较 如果快指针和慢指针不相同，说明之前的数字都是最多出现两次的，把慢指针 p1 改为当前不同的数字下标，也就是快指针 p2 12345678910111213141516171819/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var removeDuplicates = function(nums) &#123; let p1 = 0 let p2 = 1 while (p2 &lt; nums.length) &#123; if(nums[p2] == nums[p1] &amp;&amp; nums[p2 + 1] == nums[p1]) &#123; nums.splice(p2, 1) &#125; else if(nums[p2] !== nums[p1])&#123; p1 = p2 p2++ &#125; else &#123; p2++ &#125; &#125;&#125;;","content":"<!--\n * @File: \n * @Author: 张宏亮 - zhl@xiaoniren.cn\n * @Date: 2019-08-18 15:46:12\n * @LastEditors: 张宏亮<zhl@xiaoniren.cn>\n * @LastEditTime: 2019-08-24 11:45:57\n * @Description: file content\n * @Versions: 1.0.0\n -->\n<h3 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h3><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。</p>\n<p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p>\n<p>示例 1:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给定 nums = [1,1,1,2,2,3],</span><br><span class=\"line\"></span><br><span class=\"line\">函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。</span><br><span class=\"line\"></span><br><span class=\"line\">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure></p>\n<p>示例 2:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给定 nums = [0,0,1,1,1,1,2,3,3],</span><br><span class=\"line\"></span><br><span class=\"line\">函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。</span><br><span class=\"line\"></span><br><span class=\"line\">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure></p>\n<p>说明:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">为什么返回数值是整数，但输出的答案是数组呢?</span><br><span class=\"line\"></span><br><span class=\"line\">请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</span><br></pre></td></tr></table></figure></p>\n<p>你可以想象内部操作如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span><br><span class=\"line\">int len = removeDuplicates(nums);</span><br><span class=\"line\"></span><br><span class=\"line\">// 在函数里修改输入数组对于调用者是可见的。</span><br><span class=\"line\">// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</span><br><span class=\"line\">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class=\"line\">    print(nums[i]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<p>标签 <strong>双指针</strong> <strong>数组</strong></p>\n<h3 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>原地算法，就是不依赖额外的资源或者依赖少数的额外资源，仅依靠输出来覆盖输入的一种算法操作。</p>\n<p>在不复制数组的情况下从数组中删除元素的一些提示：</p>\n<ul>\n<li>尝试双指针法。</li>\n<li>你是否使用“元素顺序可以更改”这一属性？</li>\n<li>当要删除的元素很少时会发生什么？</li>\n</ul>\n<h3 id=\"解法一：数组api\"><a href=\"#解法一：数组api\" class=\"headerlink\" title=\"解法一：数组api\"></a>解法一：数组api</h3><p>定义 nums[0…i] 满足每个元素最多出现两次，遍历整个数列不断的维护这个定义。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;number[]&#125;</span> <span class=\"variable\">nums</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return <span class=\"type\">&#123;number&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> removeDuplicates = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">nums</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> i = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (i &lt; nums.length) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums[i] === nums[i - <span class=\"number\">2</span>]) &#123;</span><br><span class=\"line\">      nums.splice(i, <span class=\"number\">1</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      i++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"解法二：双指针\"><a href=\"#解法二：双指针\" class=\"headerlink\" title=\"解法二：双指针\"></a>解法二：双指针</h3><p>维护两个指针，</p>\n<ol>\n<li>慢指针 p1 初始为 0 ，快指针 p2 初始为 1</li>\n<li>如果快指针的后一位 (p2 + 1) 和前一位( p1 )都相同，那说明该元素出现三次。</li>\n<li>出现三次把快指针 p2 下元素原地删除，快指针不变，继续比较</li>\n<li>如果快指针和慢指针不相同，说明之前的数字都是最多出现两次的，把慢指针 p1 改为当前不同的数字下标，也就是快指针 p2</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;number[]&#125;</span> <span class=\"variable\">nums</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return <span class=\"type\">&#123;number&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> removeDuplicates = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">nums</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> p1 = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> p2 = <span class=\"number\">1</span></span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">while</span> (p2 &lt; nums.length) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(nums[p2] == nums[p1] &amp;&amp; nums[p2 + <span class=\"number\">1</span>] == nums[p1]) &#123;</span><br><span class=\"line\">        nums.splice(p2, <span class=\"number\">1</span>)</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(nums[p2] !== nums[p1])&#123;</span><br><span class=\"line\">        p1 = p2</span><br><span class=\"line\">        p2++</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        p2++</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"leetcode.75.颜色分类","text":"题目描述给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。 此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。 注意:1不能使用代码库中的排序函数来解决这道题。 示例:12输入: [2,0,2,1,1,0]输出: [0,0,1,1,2,2] 进阶：12一个直观的解决方案是使用计数排序的两趟扫描算法。首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。 你能想出一个仅使用常数空间的一趟扫描算法吗？ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/sort-colors著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 标签 排序 双指针 数组 解题思路这道题的排序不是排[2,0,2,1,1,0]，这个只是抽象出来的。。 所以不止 sort 不能用，冒泡插入之类的排序也是不行的。 解法一：三指针时间复杂度O(n) 我们可以把数组分成三部分，前部（全部是0），中部（全部是1）和后部（全部是2）三个部分，每一个元素（红白蓝分别对应0、1、2）必属于其中之一。 将前部和后部各排在数组的前边和后边，中部自然就排好了。 我们用三个指针（p0, p2 和curr）来分别追踪0的最右边界，2的最左边界和当前考虑的元素。 本解法的思路是沿着数组移动 curr 指针，若nums[curr] = 0，则将其与 nums[p0]互换；若 nums[curr] = 2 ，则与 nums[p2]互换。 初始化0的最右边界：p0 = 0。在整个算法执行过程中 nums[idx &lt; p0] = 0. 初始化2的最左边界 ：p2 = n - 1。在整个算法执行过程中 nums[idx &gt; p2] = 2. 初始化当前考虑的元素序号 ：curr = 0. While curr &lt;= p2 : 若 nums[curr] = 0 ：交换第 curr个 和 第p0个 元素，并将指针都向右移。 若 nums[curr] = 2 ：交换第 curr个和第 p2个元素，并将 p2指针左移 。 若 nums[curr] = 1 ：将指针curr右移。 12345678910111213141516171819var sortColors = function(nums) &#123; if (nums.length &gt; 1) &#123; var p0 = 0, p2 = nums.length - 1, curr = 0 &#125; while (curr &lt;= p2) &#123; if (nums[curr] == 0) &#123; ;[nums[p0], nums[curr]] = [nums[curr], nums[p0]] p0++ curr++ &#125; else if (nums[curr] == 2) &#123; ;[nums[p2], nums[curr]] = [nums[curr], nums[p2]] p2-- &#125; else &#123; curr++ &#125; &#125;&#125; 解法二：计数排序时间复杂度O(n) 这样写也能过，但是这个不算是原地排序了。。 我们看一下计数排序是怎么运作 假设我们有[1,2,3,1,0,4]这六个数，这里面最大的值为4 那么我们创建一个长度为4+1的数组，每个元素默认为0。 这相当于选举排序，一共有6个投票箱，1就投1号箱，0就投入0号箱。 注意，这些箱本来就是已经排好序，并且箱的编号就是代表原数组的元素。当全部投完时，0号箱有1个，1号箱有2个，2号箱有1个，3号箱有1，4号箱有1个。 然后我们从这些箱的所有数依次出来，放到新数组，就神奇地排好序了。 计数排序没有对元素进行比较，只是利用了箱与元素的一一对应关系，根据箱已经排好序的先决条件，解决排序。 1234567891011121314151617181920212223/** * @param &#123;number[]&#125; nums * @return &#123;void&#125; Do not return anything, modify nums in-place instead. */var sortColors = function(nums) &#123; let stackLength = Math.max(...nums) // 获取数组里最大值 let countArr = Array(stackLength + 1).fill(0) // 创建长度为最大值+1的临时数组，并将元素设为0 for(let i = 0; i &lt; nums.length; i ++)&#123; // 遍历数组，在临时数组对应 key 上计数 countArr[nums[i]] += 1 &#125; nums.length = 0 // 因为题目要求原地排序 for(let i = 0; i &lt; countArr.length; i++) &#123; // 把计数数组按顺序放回原数组 while(countArr[i]) &#123; nums.push(i) countArr[i]-- &#125; &#125;&#125;;","content":"<!--\n * @File: \n * @Author: 张宏亮 - zhl@xiaoniren.cn\n * @Date: 2019-08-18 15:46:12\n * @LastEditors: 张宏亮<zhl@xiaoniren.cn>\n * @LastEditTime: 2019-08-24 13:45:34\n * @Description: file content\n * @Versions: 1.0.0\n -->\n<h3 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h3><p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p>\n<p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p>\n<p>注意:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">不能使用代码库中的排序函数来解决这道题。</span><br></pre></td></tr></table></figure></p>\n<p>示例:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [2,0,2,1,1,0]</span><br><span class=\"line\">输出: [0,0,1,1,2,2]</span><br></pre></td></tr></table></figure></p>\n<p>进阶：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">一个直观的解决方案是使用计数排序的两趟扫描算法。</span><br><span class=\"line\">首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。</span><br></pre></td></tr></table></figure></p>\n<p>你能想出一个仅使用常数空间的一趟扫描算法吗？</p>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/sort-colors\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/sort-colors</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<p>标签 <strong>排序</strong> <strong>双指针</strong> <strong>数组</strong></p>\n<h3 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>这道题的排序不是排[2,0,2,1,1,0]，这个只是抽象出来的。。</p>\n<p>所以不止 sort 不能用，冒泡插入之类的排序也是不行的。</p>\n<h3 id=\"解法一：三指针\"><a href=\"#解法一：三指针\" class=\"headerlink\" title=\"解法一：三指针\"></a>解法一：三指针</h3><p>时间复杂度O(n)</p>\n<p>我们可以把数组分成三部分，前部（全部是0），中部（全部是1）和后部（全部是2）三个部分，每一个元素（红白蓝分别对应0、1、2）必属于其中之一。</p>\n<p>将前部和后部各排在数组的前边和后边，中部自然就排好了。</p>\n<p>我们用三个指针（p0, p2 和curr）来分别追踪0的最右边界，2的最左边界和当前考虑的元素。</p>\n<p>本解法的思路是沿着数组移动 curr 指针，若nums[curr] = 0，则将其与 nums[p0]互换；若 nums[curr] = 2 ，则与 nums[p2]互换。</p>\n<ul>\n<li>初始化0的最右边界：p0 = 0。在整个算法执行过程中 nums[idx &lt; p0] = 0.</li>\n<li>初始化2的最左边界 ：p2 = n - 1。在整个算法执行过程中 nums[idx &gt; p2] = 2.</li>\n<li>初始化当前考虑的元素序号 ：curr = 0.</li>\n<li><p>While curr &lt;= p2 :</p>\n<ol>\n<li><p>若 nums[curr] = 0 ：交换第 curr个 和 第p0个 元素，并将指针都向右移。</p>\n</li>\n<li><p>若 nums[curr] = 2 ：交换第 curr个和第 p2个元素，并将 p2指针左移 。</p>\n</li>\n<li><p>若 nums[curr] = 1 ：将指针curr右移。</p>\n</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sortColors = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">nums</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (nums.length &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> p0 = <span class=\"number\">0</span>,</span><br><span class=\"line\">      p2 = nums.length - <span class=\"number\">1</span>,</span><br><span class=\"line\">      curr = <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (curr &lt;= p2) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums[curr] == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      ;[nums[p0], nums[curr]] = [nums[curr], nums[p0]]</span><br><span class=\"line\">      p0++</span><br><span class=\"line\">      curr++</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[curr] == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">      ;[nums[p2], nums[curr]] = [nums[curr], nums[p2]]</span><br><span class=\"line\">      p2--</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      curr++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"解法二：计数排序\"><a href=\"#解法二：计数排序\" class=\"headerlink\" title=\"解法二：计数排序\"></a>解法二：计数排序</h3><p>时间复杂度O(n)</p>\n<p>这样写也能过，但是这个不算是原地排序了。。</p>\n<p>我们看一下计数排序是怎么运作</p>\n<p>假设我们有[1,2,3,1,0,4]这六个数，这里面最大的值为4</p>\n<p>那么我们创建一个长度为4+1的数组，每个元素默认为0。</p>\n<p>这相当于选举排序，一共有6个投票箱，1就投1号箱，0就投入0号箱。</p>\n<p>注意，这些箱本来就是已经排好序，并且箱的编号就是代表原数组的元素。当全部投完时，0号箱有1个，1号箱有2个，2号箱有1个，3号箱有1，4号箱有1个。</p>\n<p>然后我们从这些箱的所有数依次出来，放到新数组，就神奇地排好序了。</p>\n<p>计数排序没有对元素进行比较，只是利用了箱与元素的一一对应关系，根据箱已经排好序的先决条件，解决排序。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;number[]&#125;</span> <span class=\"variable\">nums</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return <span class=\"type\">&#123;void&#125;</span> </span>Do not return anything, modify nums in-place instead.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> sortColors = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">nums</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> stackLength = <span class=\"built_in\">Math</span>.max(...nums)   <span class=\"comment\">// 获取数组里最大值 </span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> countArr = <span class=\"built_in\">Array</span>(stackLength + <span class=\"number\">1</span>).fill(<span class=\"number\">0</span>)   <span class=\"comment\">// 创建长度为最大值+1的临时数组，并将元素设为0</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i ++)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 遍历数组，在临时数组对应 key 上计数</span></span><br><span class=\"line\">        countArr[nums[i]] += <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    nums.length = <span class=\"number\">0</span>   <span class=\"comment\">// 因为题目要求原地排序</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; countArr.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 把计数数组按顺序放回原数组</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(countArr[i]) &#123;</span><br><span class=\"line\">            nums.push(i)</span><br><span class=\"line\">            countArr[i]--</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"leetcode.50.Pow(x, n)","text":"题目描述实现 pow(x, n) ，即计算 x 的 n 次幂函数。 示例 1:12输入: 2.00000, 10输出: 1024.00000 示例 2:12输入: 2.10000, 3输出: 9.26100 示例 3:123输入: 2.00000, -2输出: 0.25000解释: 2-2 = 1/22 = 1/4 = 0.25 说明:12-100.0 &lt; x &lt; 100.0n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/powx-n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 标签 数学 二分查找 解法一：暴力法时间复杂度O(n) 模拟计算过程 如果 n &lt; 0 , n = -n, x = $\\frac{1}{x}$ 可以看示例3 不过这个会超时1234567891011121314151617/** * @param &#123;number&#125; x * @param &#123;number&#125; n * @return &#123;number&#125; */var myPow = function(x, n) &#123; if( n &lt; 0) &#123; x = 1 / x n = -n &#125; let res = 1 for(let i = 0; i &lt; n; i++) &#123; res *= x &#125; return res&#125;; 解法二：分治，二分时间复杂度O(n log n) 数学， 如果 n 为 0，那结果为 1 如果 n 为 1，那结果为 x 如果 n &lt; 0, n = -n, x = $\\frac{1}{x}$ 如果 n &gt; 0，正常计算 算法， 如果 n 是偶数位，那二分，结果就是 $x^\\frac{n}{2} \\times\\ x^\\frac{n}{2}$ 如果 n 是奇数位，那二分，结果就是 $x^\\frac{n}{2} \\times\\ x^\\frac{n}{2} \\times\\ x$ 比如 $2^4$ 就是 $2^2 \\times\\ 2^2$ ， $2^5$ 就是 $2^2 \\times\\ 2^2 \\times\\ 2$， 一直二分递归到 n 为 1 或者 0 1234567891011121314151617181920212223/** * @param &#123;number&#125; x * @param &#123;number&#125; n * @return &#123;number&#125; */var myPow = function(x, n) &#123; if(n === 0) &#123; return 1 &#125; if(n === 1) &#123; return x &#125; if(n &lt; 0) &#123; return myPow(1/x, -n) &#125; let half = ~~(n/2) let temp = myPow(x, half) if(n % 2 === 0) &#123; return temp * temp &#125; else &#123; return temp * temp * x &#125;&#125;;","content":"<h3 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h3><p>实现 pow(x, n) ，即计算 x 的 n 次幂函数。</p>\n<p>示例 1:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: 2.00000, 10</span><br><span class=\"line\">输出: 1024.00000</span><br></pre></td></tr></table></figure></p>\n<p>示例 2:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: 2.10000, 3</span><br><span class=\"line\">输出: 9.26100</span><br></pre></td></tr></table></figure></p>\n<p>示例 3:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: 2.00000, -2</span><br><span class=\"line\">输出: 0.25000</span><br><span class=\"line\">解释: 2-2 = 1/22 = 1/4 = 0.25</span><br></pre></td></tr></table></figure></p>\n<p>说明:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-100.0 &lt; x &lt; 100.0</span><br><span class=\"line\">n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。</span><br></pre></td></tr></table></figure></p>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/powx-n\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/powx-n</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<p>标签 <strong>数学</strong> <strong>二分查找</strong></p>\n<h3 id=\"解法一：暴力法\"><a href=\"#解法一：暴力法\" class=\"headerlink\" title=\"解法一：暴力法\"></a>解法一：暴力法</h3><p>时间复杂度O(n)</p>\n<p>模拟计算过程</p>\n<p>如果 n &lt; 0 , n = -n, x = $\\frac{1}{x}$</p>\n<p>可以看示例3</p>\n<p>不过这个会超时<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;number&#125;</span> <span class=\"variable\">x</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;number&#125;</span> <span class=\"variable\">n</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return <span class=\"type\">&#123;number&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> myPow = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x, n</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>( n &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        x = <span class=\"number\">1</span> / x</span><br><span class=\"line\">        n = -n</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> res = <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">        res *= x</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"解法二：分治，二分\"><a href=\"#解法二：分治，二分\" class=\"headerlink\" title=\"解法二：分治，二分\"></a>解法二：分治，二分</h3><p>时间复杂度O(n log n)</p>\n<p>数学，</p>\n<ol>\n<li>如果 n 为 0，那结果为 1</li>\n<li>如果 n 为 1，那结果为 x</li>\n<li>如果 n &lt; 0, n = -n, x = $\\frac{1}{x}$</li>\n<li>如果 n &gt; 0，正常计算</li>\n</ol>\n<p>算法，</p>\n<ol>\n<li>如果 n 是偶数位，那二分，结果就是 $x^\\frac{n}{2} \\times\\ x^\\frac{n}{2}$</li>\n<li>如果 n 是奇数位，那二分，结果就是 $x^\\frac{n}{2} \\times\\ x^\\frac{n}{2} \\times\\ x$</li>\n<li>比如 $2^4$ 就是 $2^2 \\times\\ 2^2$ ， $2^5$ 就是 $2^2 \\times\\ 2^2 \\times\\ 2$，</li>\n<li>一直二分递归到 n 为 1 或者 0</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;number&#125;</span> <span class=\"variable\">x</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;number&#125;</span> <span class=\"variable\">n</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return <span class=\"type\">&#123;number&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> myPow = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x, n</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> myPow(<span class=\"number\">1</span>/x, -n)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> half = ~~(n/<span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> temp = myPow(x, half)</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n % <span class=\"number\">2</span> === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> temp * temp</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> temp * temp * x</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"leetcode.49.字母异位词分组","text":"题目描述给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。 示例:1234567输入: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],输出:[ [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;], [&quot;nat&quot;,&quot;tan&quot;], [&quot;bat&quot;]] 说明： 所有输入均为小写字母。 不考虑答案输出的顺序。 标签 哈希表 字符串 https://leetcode-cn.com/problems/group-anagrams/ 解法一：哈希表当且仅当它们的排序字符串相等时，两个字符串是字母异位词。 维护一个哈希映射 ans : {String -&gt; List}，其中每个键 K 是一个排序字符串，每个值是初始输入的字符串列表，排序后等于 K。 时间复杂度：O(NKlogK)，其中 N 是 strs 的长度，而 K 是 strs 中字符串的最大长度。当我们遍历每个字符串时，外部循环具有的复杂度为 O(N)。然后，我们在 O(KlogK) 的时间内对每个字符串排序。 1234567891011121314151617181920/** * @param &#123;string[]&#125; strs * @return &#123;string[][]&#125; */var groupAnagrams = function(strs) &#123; let hash = new Map() for(let i = 0; i &lt; strs.length; i++) &#123; let str = strs[i].split('').sort().join() if(hash.has(str)) &#123; let temp = hash.get(str) temp.push(strs[i]) hash.set(str, temp) &#125; else &#123; hash.set(str, [strs[i]]) &#125; &#125; return [...hash.values()]&#125;; 解法二：利用数学设计键 算术基本定理，又称为正整数的唯一分解定理，即：每个大于1的自然数，要么本身就是质数，要么可以写为2个以上的质数的积，而且这些质因子按大小排列之后，写法仅有一种方式。 利用这个，我们把每个字符串都映射到一个正数上。 用一个数组存储质数 prime = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103]。 然后每个字符串的字符减去 ‘ a ‘ ，然后取到 prime 中对应的质数。把它们累乘。 例如 abc ，就对应 ‘a’ - ‘a’， ‘b’ - ‘a’， ‘c’ - ‘a’，即 0, 1, 2，也就是对应素数 2 3 5，然后相乘 2 3 5 = 30，就把 “abc” 映射到了 30。 相减时用 Unicode 编码。 和解法一的理论差不多，不过少了字符串的排序。 也就是用另外一种方式解决了哈希设计键。 时间复杂度 O(NK) 12345678910111213var groupAnagrams = function(strs) &#123; let res = &#123;&#125;; for(let i = 0; i &lt; strs.length; i++) &#123; const str = strs[i] const hash = str.split('').reduce((sum, s)=&gt;&#123; return sum * [3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103 ][s.charCodeAt(0) - 97] &#125;, 1) res[hash] ? res[hash].push(str) : res[hash] = [str] &#125; return Object.values(res)&#125;; 解法三：计数 首先初始化 key = “0#0#0#0#0#”，数字分别代表 abcde 出现的次数，# 用来分割。 这样的话，”abb” 就映射到了 “1#2#0#0#0”。 “cdc” 就映射到了 “0#0#2#1#0”。 “dcc” 就映射到了 “0#0#2#1#0”。 然后和其他解法一样，如果 key 一样，就把值映射到对应的 key 里。 时间复杂度：O(NK)。 123456789101112131415161718192021222324/** * @param &#123;string[]&#125; strs * @return &#123;string[][]&#125; */var groupAnagrams = function(strs) &#123; let hash = new Map() for(let i = 0; i &lt; strs.length; i++) &#123; let str = strs[i] let arr = Array(26).fill(0) for(let j = 0; j &lt; str.length; j++) &#123; arr[str.charCodeAt(j) - 97] ++ &#125; let hashKey = arr.join() if(hash.has(hashKey)) &#123; let temp = hash.get(hashKey) temp.push(str) hash.set(hashKey, temp) &#125; else &#123; hash.set(hashKey, [str]) &#125; &#125; return [...hash.values()]&#125;; 所有的方法基本上都是为哈希表设计合适的键 因为需要几个值同时对应同一个键 所以要找到一个合适键的规则","content":"<h3 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h3><p>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</p>\n<p>示例:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],</span><br><span class=\"line\">输出:</span><br><span class=\"line\">[</span><br><span class=\"line\">  [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],</span><br><span class=\"line\">  [&quot;nat&quot;,&quot;tan&quot;],</span><br><span class=\"line\">  [&quot;bat&quot;]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure></p>\n<p>说明：</p>\n<p>所有输入均为小写字母。</p>\n<p>不考虑答案输出的顺序。</p>\n<p>标签 <strong>哈希表</strong> <strong>字符串</strong></p>\n<p><a href=\"https://leetcode-cn.com/problems/group-anagrams/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/group-anagrams/</a></p>\n<h3 id=\"解法一：哈希表\"><a href=\"#解法一：哈希表\" class=\"headerlink\" title=\"解法一：哈希表\"></a>解法一：哈希表</h3><p>当且仅当它们的排序字符串相等时，两个字符串是字母异位词。</p>\n<p>维护一个哈希映射 ans : {String -&gt; List}，其中每个键 K 是一个排序字符串，每个值是初始输入的字符串列表，排序后等于 K。</p>\n<p><img src=\"https://raw.githubusercontent.com/zhl1232/javascript-algorithm/master/static/img/49.png\" alt=\"image\"></p>\n<p>时间复杂度：O(NKlogK)，其中 N 是 strs 的长度，而 K 是 strs 中字符串的最大长度。当我们遍历每个字符串时，外部循环具有的复杂度为 O(N)。然后，我们在 O(KlogK) 的时间内对每个字符串排序。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;string[]&#125;</span> <span class=\"variable\">strs</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return <span class=\"type\">&#123;string[][]&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> groupAnagrams = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">strs</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> hash = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>()</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> str = strs[i].split(<span class=\"string\">''</span>).sort().join()</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(hash.has(str)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> temp = hash.get(str)</span><br><span class=\"line\">            temp.push(strs[i])</span><br><span class=\"line\">            hash.set(str, temp)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            hash.set(str, [strs[i]])</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> [...hash.values()]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"解法二：利用数学设计键\"><a href=\"#解法二：利用数学设计键\" class=\"headerlink\" title=\"解法二：利用数学设计键\"></a>解法二：利用数学设计键</h3><blockquote>\n<p>算术基本定理，又称为正整数的唯一分解定理，即：每个大于1的自然数，要么本身就是质数，要么可以写为2个以上的质数的积，而且这些质因子按大小排列之后，写法仅有一种方式。</p>\n</blockquote>\n<p>利用这个，我们把每个字符串都映射到一个正数上。</p>\n<ul>\n<li><p>用一个数组存储质数 prime = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103]。</p>\n</li>\n<li><p>然后每个字符串的字符减去 ‘ a ‘ ，然后取到 prime 中对应的质数。把它们累乘。</p>\n</li>\n<li><p>例如 abc ，就对应 ‘a’ - ‘a’， ‘b’ - ‘a’， ‘c’ - ‘a’，即 0, 1, 2，也就是对应素数 2 3 5，然后相乘 2 <em> 3 </em> 5 = 30，就把 “abc” 映射到了 30。</p>\n</li>\n<li><p>相减时用 Unicode 编码。</p>\n</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/zhl1232/javascript-algorithm/master/static/img/49-1.png\" alt=\"image\"></p>\n<p>和解法一的理论差不多，不过少了字符串的排序。</p>\n<p>也就是用另外一种方式解决了哈希设计键。</p>\n<p>时间复杂度 O(NK)</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> groupAnagrams = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">strs</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">let</span> res = &#123;&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">const</span> str = strs[i]</span><br><span class=\"line\">\t\t<span class=\"keyword\">const</span> hash = str.split(<span class=\"string\">''</span>).reduce(<span class=\"function\">(<span class=\"params\">sum, s</span>)=&gt;</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> sum * [<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>,<span class=\"number\">11</span>,<span class=\"number\">13</span>,<span class=\"number\">17</span>,<span class=\"number\">19</span>,<span class=\"number\">23</span>,<span class=\"number\">29</span>,<span class=\"number\">31</span>,<span class=\"number\">37</span>,<span class=\"number\">41</span>,<span class=\"number\">43</span>,<span class=\"number\">47</span>,<span class=\"number\">53</span>,<span class=\"number\">59</span>,<span class=\"number\">61</span>,<span class=\"number\">67</span>,<span class=\"number\">71</span>,<span class=\"number\">73</span>,<span class=\"number\">79</span>,<span class=\"number\">83</span>,<span class=\"number\">89</span>,<span class=\"number\">97</span>,<span class=\"number\">101</span>,<span class=\"number\">103</span> ][s.charCodeAt(<span class=\"number\">0</span>) - <span class=\"number\">97</span>]</span><br><span class=\"line\">\t\t&#125;, <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\tres[hash] ? res[hash].push(str) : res[hash] = [str]</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.values(res)</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"解法三：计数\"><a href=\"#解法三：计数\" class=\"headerlink\" title=\"解法三：计数\"></a>解法三：计数</h3><ul>\n<li><p>首先初始化 key = “0#0#0#0#0#”，数字分别代表 abcde 出现的次数，# 用来分割。</p>\n</li>\n<li><p>这样的话，”abb” 就映射到了 “1#2#0#0#0”。</p>\n</li>\n<li><p>“cdc” 就映射到了 “0#0#2#1#0”。</p>\n</li>\n<li><p>“dcc” 就映射到了 “0#0#2#1#0”。</p>\n</li>\n</ul>\n<p>然后和其他解法一样，如果 key 一样，就把值映射到对应的 key 里。</p>\n<p>时间复杂度：O(NK)。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;string[]&#125;</span> <span class=\"variable\">strs</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return <span class=\"type\">&#123;string[][]&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> groupAnagrams = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">strs</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> hash = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>()</span><br><span class=\"line\">     </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> str = strs[i]</span><br><span class=\"line\">        <span class=\"keyword\">let</span> arr = <span class=\"built_in\">Array</span>(<span class=\"number\">26</span>).fill(<span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; str.length; j++) &#123;</span><br><span class=\"line\">            arr[str.charCodeAt(j) - <span class=\"number\">97</span>] ++</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> hashKey = arr.join()</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(hash.has(hashKey)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> temp = hash.get(hashKey)</span><br><span class=\"line\">            temp.push(str)</span><br><span class=\"line\">            hash.set(hashKey, temp)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            hash.set(hashKey, [str])</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [...hash.values()]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>所有的方法基本上都是为哈希表设计合适的键</p>\n<p>因为需要几个值同时对应同一个键</p>\n<p>所以要找到一个合适键的规则</p>\n"},{"title":"leetcode.36.有效的数独","text":"题目描述判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。 数字 1-9 在每一行只能出现一次。数字 1-9 在每一列只能出现一次。数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。 上图是一个部分填充的有效的数独。 数独部分空格内已填入了数字，空白格用 ‘.’ 表示。 示例 1:12345678910111213输入:[ [&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;], [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;], [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;], [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;], [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]输出: true 示例 2:12345678910111213输入:[ [&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;], [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;], [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;], [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;], [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]输出: false 解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。 说明:一个有效的数独（部分已被填充）不一定是可解的。只需要根据以上规则，验证已经填入的数字是否有效即可。给定数独序列只包含数字 1-9 和字符 ‘.’ 。给定数独永远是 9x9 形式的。 标签 哈希表 https://leetcode-cn.com/problems/valid-sudoku/ 方法一：一次迭代思路： 每一行、每一列、每一个小正方形都不能重复出现相同数字 用hash记录它的行，列和小正方形的值，有重复就false 可以用 (~~(i/3))*3 + ~~(j/3) 来确定小正方块的位置 时间复杂度：O(1)，因为我们只对 81 个单元格进行了一次迭代。 123456789101112131415161718192021222324252627282930313233343536/** * @param &#123;character[][]&#125; board * @return &#123;boolean&#125; */var isValidSudoku = function(board) &#123; let rows = new Map() let cols = new Map() let boxs = new Map() for(let i = 0; i &lt; board.length; i++) &#123; rows.set(`rows$&#123;i&#125;`, new Map()) cols.set(`cols$&#123;i&#125;`, new Map()) boxs.set(`boxs$&#123;i&#125;`, new Map()) &#125; for(let i = 0; i &lt; board.length; i++) &#123; for(let j = 0; j &lt; board[i].length; j++) &#123; if(board[i][j] == '.') continue let boxIndex = (~~(i/3))*3 + ~~(j/3) let row = rows.get(`rows$&#123;i&#125;`) let col = cols.get(`cols$&#123;j&#125;`) let box = boxs.get(`boxs$&#123;boxIndex&#125;`) if(row.has(board[i][j]) || col.has(board[i][j]) || box.has(board[i][j])) &#123; return false &#125; else &#123; row.set(board[i][j], 1) col.set(board[i][j], 1) box.set(board[i][j], 1) &#125; &#125; &#125; return true&#125;; 方法二：三次迭代一个简单的解决方案是遍历该 9 x 9 数独 三 次，以确保： 行中没有重复的数字。 列中没有重复的数字。 3 x 3 子数独内没有重复的数字。 这个没啥说的。 1234567891011121314151617181920212223242526272829303132333435363738/** * @param &#123;character[][]&#125; board * @return &#123;boolean&#125; */var isValidSudoku = function(board) &#123; for (let i = 0; i &lt; 9; i++) &#123; // 检查行重复项 let row = &#123;&#125;; for (let j = 0; j &lt; 9; j++) &#123; if (board[i][j] !== '.') &#123; if (row[board[i][j]]) return false; row[board[i][j]] = 1; &#125; &#125; &#125; for (let i = 0; i &lt; 9; i++) &#123; // 检查列重复项 let col = &#123;&#125;; for (let j = 0; j &lt; 9; j++) &#123; if (board[j][i] !== '.') &#123; if (col[board[j][i]]) return false; col[board[j][i]] = 1; &#125; &#125; &#125; for (let i = 0; i &lt; 9; i += 3) &#123; // 检查3*3宫格重复项 for (let j = 0; j &lt; 9; j += 3) &#123; let miniTable = &#123;&#125;; for (let m = i; m &lt; i + 3; m++) &#123; for (let n = j; n &lt; j + 3; n++) &#123; if (board[m][n] !== '.') &#123; if (miniTable[board[m][n]]) return false; miniTable[board[m][n]] = 1; &#125; &#125; &#125; &#125; &#125; return true;&#125;;","content":"<h3 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h3><p>判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。</p>\n<p>数字 1-9 在每一行只能出现一次。<br>数字 1-9 在每一列只能出现一次。<br>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。</p>\n<p><img src=\"https://raw.githubusercontent.com/zhl1232/javascript-algorithm/master/static/img/36.png\" alt=\"image\"></p>\n<p>上图是一个部分填充的有效的数独。</p>\n<p>数独部分空格内已填入了数字，空白格用 ‘.’ 表示。</p>\n<p>示例 1:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入:</span><br><span class=\"line\">[</span><br><span class=\"line\">  [&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class=\"line\">  [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class=\"line\">  [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],</span><br><span class=\"line\">  [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],</span><br><span class=\"line\">  [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],</span><br><span class=\"line\">  [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],</span><br><span class=\"line\">  [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],</span><br><span class=\"line\">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],</span><br><span class=\"line\">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]</span><br><span class=\"line\">]</span><br><span class=\"line\">输出: true</span><br></pre></td></tr></table></figure></p>\n<p>示例 2:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入:</span><br><span class=\"line\">[</span><br><span class=\"line\">  [&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class=\"line\">  [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class=\"line\">  [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],</span><br><span class=\"line\">  [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],</span><br><span class=\"line\">  [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],</span><br><span class=\"line\">  [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],</span><br><span class=\"line\">  [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],</span><br><span class=\"line\">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],</span><br><span class=\"line\">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]</span><br><span class=\"line\">]</span><br><span class=\"line\">输出: false</span><br></pre></td></tr></table></figure></p>\n<p>解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。<br>     但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。</p>\n<p>说明:<br>一个有效的数独（部分已被填充）不一定是可解的。<br>只需要根据以上规则，验证已经填入的数字是否有效即可。<br>给定数独序列只包含数字 1-9 和字符 ‘.’ 。<br>给定数独永远是 9x9 形式的。</p>\n<p>标签 <strong>哈希表</strong></p>\n<p><a href=\"https://leetcode-cn.com/problems/valid-sudoku/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/valid-sudoku/</a></p>\n<h3 id=\"方法一：一次迭代\"><a href=\"#方法一：一次迭代\" class=\"headerlink\" title=\"方法一：一次迭代\"></a>方法一：一次迭代</h3><p>思路：</p>\n<ul>\n<li>每一行、每一列、每一个小正方形都不能重复出现相同数字</li>\n<li>用hash记录它的行，列和小正方形的值，有重复就false</li>\n<li>可以用 (~~(i/3))*3 + ~~(j/3) 来确定小正方块的位置</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/zhl1232/javascript-algorithm/master/static/img/36-1.png\" alt=\"image\"></p>\n<p>时间复杂度：O(1)，因为我们只对 81 个单元格进行了一次迭代。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;character[][]&#125;</span> <span class=\"variable\">board</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return <span class=\"type\">&#123;boolean&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> isValidSudoku = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">board</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> rows = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>()</span><br><span class=\"line\">    <span class=\"keyword\">let</span> cols = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>()</span><br><span class=\"line\">    <span class=\"keyword\">let</span> boxs = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>() </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; board.length; i++) &#123;</span><br><span class=\"line\">        rows.set(<span class=\"string\">`rows<span class=\"subst\">$&#123;i&#125;</span>`</span>, <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>())</span><br><span class=\"line\">        cols.set(<span class=\"string\">`cols<span class=\"subst\">$&#123;i&#125;</span>`</span>, <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>())</span><br><span class=\"line\">        boxs.set(<span class=\"string\">`boxs<span class=\"subst\">$&#123;i&#125;</span>`</span>, <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; board.length; i++) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; board[i].length; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(board[i][j] == <span class=\"string\">'.'</span>) <span class=\"keyword\">continue</span></span><br><span class=\"line\">            <span class=\"keyword\">let</span> boxIndex = (~~(i/<span class=\"number\">3</span>))*<span class=\"number\">3</span> + ~~(j/<span class=\"number\">3</span>)</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">let</span> row = rows.get(<span class=\"string\">`rows<span class=\"subst\">$&#123;i&#125;</span>`</span>)</span><br><span class=\"line\">            <span class=\"keyword\">let</span> col = cols.get(<span class=\"string\">`cols<span class=\"subst\">$&#123;j&#125;</span>`</span>)</span><br><span class=\"line\">            <span class=\"keyword\">let</span> box = boxs.get(<span class=\"string\">`boxs<span class=\"subst\">$&#123;boxIndex&#125;</span>`</span>)</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(row.has(board[i][j]) || col.has(board[i][j]) || box.has(board[i][j])) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                row.set(board[i][j], <span class=\"number\">1</span>)</span><br><span class=\"line\">                col.set(board[i][j], <span class=\"number\">1</span>)</span><br><span class=\"line\">                box.set(board[i][j], <span class=\"number\">1</span>)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"方法二：三次迭代\"><a href=\"#方法二：三次迭代\" class=\"headerlink\" title=\"方法二：三次迭代\"></a>方法二：三次迭代</h3><p>一个简单的解决方案是遍历该 9 x 9 数独 三 次，以确保：</p>\n<ul>\n<li>行中没有重复的数字。</li>\n<li>列中没有重复的数字。</li>\n<li>3 x 3 子数独内没有重复的数字。</li>\n</ul>\n<p>这个没啥说的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;character[][]&#125;</span> <span class=\"variable\">board</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return <span class=\"type\">&#123;boolean&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> isValidSudoku = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">board</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">9</span>; i++) &#123; <span class=\"comment\">// 检查行重复项</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> row = &#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">9</span>; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (board[i][j] !== <span class=\"string\">'.'</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (row[board[i][j]]) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        row[board[i][j]] = <span class=\"number\">1</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">9</span>; i++) &#123; <span class=\"comment\">// 检查列重复项</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> col = &#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">9</span>; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (board[j][i] !== <span class=\"string\">'.'</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (col[board[j][i]]) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        col[board[j][i]] = <span class=\"number\">1</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">9</span>; i += <span class=\"number\">3</span>) &#123; <span class=\"comment\">// 检查3*3宫格重复项</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">9</span>; j += <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> miniTable = &#123;&#125;;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> m = i; m &lt; i + <span class=\"number\">3</span>; m++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> n = j; n &lt; j + <span class=\"number\">3</span>; n++) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (board[m][n] !== <span class=\"string\">'.'</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (miniTable[board[m][n]]) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            miniTable[board[m][n]] = <span class=\"number\">1</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"leetcode.27.移除元素","text":"题目描述给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 示例 1:12345给定 nums = [3,2,2,3], val = 3,函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。 示例 2:1234567给定 nums = [0,1,2,2,3,0,4,2], val = 2,函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。 说明:123为什么返回数值是整数，但输出的答案是数组呢?请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下:12345678// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝int len = removeElement(nums, val);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/remove-element著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 标签 双指针 数组 解题思路原地算法，就是不依赖额外的资源或者依赖少数的额外资源，仅依靠输出来覆盖输入的一种算法操作。 在不复制数组的情况下从数组中删除元素的一些提示： 尝试双指针法。 你是否使用“元素顺序可以更改”这一属性？ 当要删除的元素很少时会发生什么？解法一：双指针 注意是原地算法，数组长度是会变动的，所以定义一个变量存储数组长度。12345678910111213141516171819/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; val * @return &#123;number&#125; */var removeElement = function(nums, val) &#123; let temp = 0 let len = nums.length for(let i = 0; i &lt; len; i++) &#123; if(nums[temp]=== val) &#123; nums.splice(temp, 1) &#125; else &#123; temp++ &#125; &#125; return nums.length&#125;; 上面的代码等于 val 的值有几个就要多做几次无意义的循环。 优化下代码。 当我们遇到 nums[i] = val 时，我们可以将当前元素与最后一个元素进行交换，并释放最后一个元素。这实际上使数组的大小减少了 1。 请注意，被交换的最后一个元素可能是您想要移除的值。但是不要担心，在下一次迭代中，我们仍然会检查这个元素。 12345678910111213141516171819/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; val * @return &#123;number&#125; */var removeElement = function(nums, val) &#123; let i = 0 let len = nums.length while(i &lt; len) &#123; if(nums[i] == val) &#123; nums[i] = nums[len - 1] len-- &#125; else &#123; i++ &#125; &#125; return len&#125;;","content":"<!--\n * @File: \n * @Author: 张宏亮 - zhl@xiaoniren.cn\n * @Date: 2019-08-18 15:46:12\n * @LastEditors: 张宏亮<zhl@xiaoniren.cn>\n * @LastEditTime: 2019-08-18 17:20:33\n * @Description: file content\n * @Versions: 1.0.0\n -->\n<h3 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h3><p>给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。</p>\n<p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p>\n<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>\n<p>示例 1:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给定 nums = [3,2,2,3], val = 3,</span><br><span class=\"line\"></span><br><span class=\"line\">函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。</span><br><span class=\"line\"></span><br><span class=\"line\">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure></p>\n<p>示例 2:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给定 nums = [0,1,2,2,3,0,4,2], val = 2,</span><br><span class=\"line\"></span><br><span class=\"line\">函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。</span><br><span class=\"line\"></span><br><span class=\"line\">注意这五个元素可为任意顺序。</span><br><span class=\"line\"></span><br><span class=\"line\">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure></p>\n<p>说明:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">为什么返回数值是整数，但输出的答案是数组呢?</span><br><span class=\"line\"></span><br><span class=\"line\">请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</span><br></pre></td></tr></table></figure></p>\n<p>你可以想象内部操作如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝</span><br><span class=\"line\">int len = removeElement(nums, val);</span><br><span class=\"line\"></span><br><span class=\"line\">// 在函数里修改输入数组对于调用者是可见的。</span><br><span class=\"line\">// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</span><br><span class=\"line\">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class=\"line\">    print(nums[i]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/remove-element\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/remove-element</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<p>标签 <strong>双指针</strong> <strong>数组</strong></p>\n<h3 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>原地算法，就是不依赖额外的资源或者依赖少数的额外资源，仅依靠输出来覆盖输入的一种算法操作。</p>\n<p>在不复制数组的情况下从数组中删除元素的一些提示：</p>\n<ul>\n<li>尝试双指针法。</li>\n<li>你是否使用“元素顺序可以更改”这一属性？</li>\n<li>当要删除的元素很少时会发生什么？<h3 id=\"解法一：双指针\"><a href=\"#解法一：双指针\" class=\"headerlink\" title=\"解法一：双指针\"></a>解法一：双指针</h3></li>\n</ul>\n<p>注意是原地算法，数组长度是会变动的，所以定义一个变量存储数组长度。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;number[]&#125;</span> <span class=\"variable\">nums</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;number&#125;</span> <span class=\"variable\">val</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return <span class=\"type\">&#123;number&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> removeElement = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">nums, val</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> temp = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> len = nums.length</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums[temp]=== val) &#123;</span><br><span class=\"line\">            nums.splice(temp, <span class=\"number\">1</span>)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            temp++</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> nums.length</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>上面的代码等于 val 的值有几个就要多做几次无意义的循环。</p>\n<p>优化下代码。</p>\n<p>当我们遇到 nums[i] = val 时，我们可以将当前元素与最后一个元素进行交换，并释放最后一个元素。这实际上使数组的大小减少了 1。</p>\n<p>请注意，被交换的最后一个元素可能是您想要移除的值。但是不要担心，在下一次迭代中，我们仍然会检查这个元素。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;number[]&#125;</span> <span class=\"variable\">nums</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;number&#125;</span> <span class=\"variable\">val</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return <span class=\"type\">&#123;number&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> removeElement = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">nums, val</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> i = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> len = nums.length</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i &lt; len) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums[i] == val) &#123;     </span><br><span class=\"line\">            nums[i] = nums[len - <span class=\"number\">1</span>]   </span><br><span class=\"line\">            len--</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            i++</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> len</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"leetcode.26.删除排序数组中的重复项","text":"题目描述给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例 1:12345给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2:12345给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。 说明:123为什么返回数值是整数，但输出的答案是数组呢?请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下:12345678// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 标签 双指针 数组 解题思路原地算法，就是不依赖额外的资源或者依赖少数的额外资源，仅依靠输出来覆盖输入的一种算法操作。 在不复制数组的情况下从数组中删除元素的一些提示： 尝试双指针法。 你是否使用“元素顺序可以更改”这一属性？ 当要删除的元素很少时会发生什么？解法一：双指针 注意是原地算法，数组长度是会变动的，所以定义一个变量存储数组长度。12345678910111213141516/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var removeDuplicates = function(nums) &#123; const length = nums.length if(length == 0) return 0 let slow = 0 for(let fast = 1; fast &lt; length; fast++) &#123; if(nums[slow] !== nums[fast]) &#123; slow++ nums[slow] = nums[fast] &#125; &#125; return slow + 1&#125;; 也可以看下 27. 移除元素 的写法，基本一样。","content":"<!--\n * @File: \n * @Author: 张宏亮 - zhl@xiaoniren.cn\n * @Date: 2019-08-18 15:46:12\n * @LastEditors: 张宏亮<zhl@xiaoniren.cn>\n * @LastEditTime: 2019-08-18 17:23:25\n * @Description: file content\n * @Versions: 1.0.0\n -->\n<h3 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h3><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>\n<p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p>\n<p>示例 1:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给定数组 nums = [1,1,2], </span><br><span class=\"line\"></span><br><span class=\"line\">函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </span><br><span class=\"line\"></span><br><span class=\"line\">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure></p>\n<p>示例 2:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给定 nums = [0,0,1,1,1,2,2,3,3,4],</span><br><span class=\"line\"></span><br><span class=\"line\">函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</span><br><span class=\"line\"></span><br><span class=\"line\">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure></p>\n<p>说明:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">为什么返回数值是整数，但输出的答案是数组呢?</span><br><span class=\"line\"></span><br><span class=\"line\">请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</span><br></pre></td></tr></table></figure></p>\n<p>你可以想象内部操作如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span><br><span class=\"line\">int len = removeDuplicates(nums);</span><br><span class=\"line\"></span><br><span class=\"line\">// 在函数里修改输入数组对于调用者是可见的。</span><br><span class=\"line\">// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</span><br><span class=\"line\">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class=\"line\">    print(nums[i]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<p>标签 <strong>双指针</strong> <strong>数组</strong></p>\n<h3 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>原地算法，就是不依赖额外的资源或者依赖少数的额外资源，仅依靠输出来覆盖输入的一种算法操作。</p>\n<p>在不复制数组的情况下从数组中删除元素的一些提示：</p>\n<ul>\n<li>尝试双指针法。</li>\n<li>你是否使用“元素顺序可以更改”这一属性？</li>\n<li>当要删除的元素很少时会发生什么？<h3 id=\"解法一：双指针\"><a href=\"#解法一：双指针\" class=\"headerlink\" title=\"解法一：双指针\"></a>解法一：双指针</h3></li>\n</ul>\n<p>注意是原地算法，数组长度是会变动的，所以定义一个变量存储数组长度。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;number[]&#125;</span> <span class=\"variable\">nums</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return <span class=\"type\">&#123;number&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> removeDuplicates = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">nums</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> length = nums.length</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(length == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> slow = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> fast = <span class=\"number\">1</span>; fast &lt; length; fast++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums[slow] !== nums[fast]) &#123;</span><br><span class=\"line\">            slow++</span><br><span class=\"line\">            nums[slow] = nums[fast]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> slow + <span class=\"number\">1</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>也可以看下 <a href=\"https://github.com/zhl1232/javascript-algorithm/tree/master/solve-problems/27.md\" target=\"_blank\" rel=\"noopener\">27. 移除元素</a> 的写法，基本一样。</p>\n"},{"title":"leetcode.24.两两交换链表中的节点","text":"题目描述给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 示例:1给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3. 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/swap-nodes-in-pairs著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 标签 链表 解题思路这道题递归和非递归其实差不多。 先拆分子问题， 要把 head 和 head.next 交换，也就是相邻的节点交换 交换之后的 head.next.next 要指向下一对交换节点的 head 节点 然后递归直到 head 或者 head.next 为 null，也就是不够两个节点进行交换 要注意递归时传入下一对交换节点的 head 节点要传哪个，1234567891011121314151617181920/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; head * @return &#123;ListNode&#125; */var swapPairs = function(head) &#123; if(!head || !head.next) &#123; return head &#125; let tempHead = head.next head.next = swapPairs(head.next.next) tempHead.next = head return tempHead&#125;; 非递归写法 12345678910111213var swapPairs = function(head) &#123; let tempHead = new ListNode(0) tempHead.next = head let prev = tempHead while(prev.next &amp;&amp; prev.next.next) &#123; let a = prev.next let b = a.next prev.next = a.next a.next = b.next prev = b.next = a &#125; return tempHead.next&#125;;","content":"<h3 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h3><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p>\n<p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>\n<p>示例:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.</span><br></pre></td></tr></table></figure></p>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/swap-nodes-in-pairs\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/swap-nodes-in-pairs</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<p>标签 <strong>链表</strong></p>\n<h3 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>这道题递归和非递归其实差不多。</p>\n<p>先拆分子问题，</p>\n<ol>\n<li>要把 head 和 head.next 交换，也就是相邻的节点交换</li>\n<li>交换之后的 head.next.next 要指向下一对交换节点的 head 节点</li>\n<li>然后递归直到 head 或者 head.next 为 null，也就是不够两个节点进行交换</li>\n<li>要注意递归时传入下一对交换节点的 head 节点要传哪个，<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * function ListNode(val) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.val = val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     this.next = null;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;ListNode&#125;</span> <span class=\"variable\">head</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return <span class=\"type\">&#123;ListNode&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> swapPairs = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">head</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!head || !head.next) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> tempHead = head.next   </span><br><span class=\"line\">    head.next = swapPairs(head.next.next)  </span><br><span class=\"line\">    tempHead.next = head</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tempHead</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>非递归写法</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> swapPairs = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">head</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> tempHead = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">    tempHead.next = head</span><br><span class=\"line\">    <span class=\"keyword\">let</span> prev = tempHead</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(prev.next &amp;&amp; prev.next.next) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> a = prev.next</span><br><span class=\"line\">        <span class=\"keyword\">let</span> b = a.next</span><br><span class=\"line\">        prev.next = a.next</span><br><span class=\"line\">        a.next = b.next</span><br><span class=\"line\">        prev = b.next = a</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tempHead.next</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"leetcode.20.有效的括号","text":"题目描述给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。 有效字符串需满足：123左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。注意空字符串可被认为是有效字符串。 示例 1:12输入: &quot;()&quot;输出: true 示例 2:12输入: &quot;()[]&#123;&#125;&quot;输出: true 示例 3:12输入: &quot;(]&quot;输出: false 示例 4:12输入: &quot;([)]&quot;输出: false 示例 5:12输入: &quot;&#123;[]&#125;&quot;输出: true 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/valid-parentheses著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 标签 栈 字符串 解题思路 如果括号数量为奇数，肯定是错误的 如果括号数量为偶数，使用栈，遍历输入字符串 如果当前字符为左半边括号时，肯定是正确的，将其压入栈中 如果遇到右半边括号时，右半边括号与栈顶的左半括号不匹配，返回错误 如果匹配，把匹配的左半括号弹出栈 图片来自： https://github.com/MisterBooo/LeetCodeAnimation 解法一1234567891011121314151617181920212223242526272829303132333435/** * @param &#123;string&#125; s * @return &#123;boolean&#125; */var isValid = function(s) &#123; let sArr = s.split('') let temp = [] let res = true if(sArr.length % 2 == 1) return false try &#123; sArr.forEach(item =&gt; &#123; if (item.match(/\\(|\\&#123;|\\[/)) &#123; temp.push(item) &#125; else &#123; if (item == ')' &amp;&amp; temp.pop() == '(') &#123; return &#125; else if (item == '&#125;' &amp;&amp; temp.pop() == '&#123;') &#123; return &#125; else if (item == ']' &amp;&amp; temp.pop() == '[') &#123; return &#125; else &#123; res = false throw new Error() // 如果为false，用try catch跳出循环 &#125; &#125; &#125;) &#125; catch (error) &#123;&#125; if (temp.length == 0 &amp;&amp; res) &#123; return true &#125; else &#123; return false &#125;&#125;; js没有现成的栈，用数组模拟可以用 try catch 跳出 forEach 循环 这道题写法可能各不相同，但解题逻辑只有这一种。 比如写法可以把每对括号存hash表里，然后匹配的时候用 key: value 匹配对应的括号 或者用for循环，跳出和return容易很多。1let hash = &#123; ')': '(', '&#125;': '&#123;', ']': '[' &#125; 扩展事实上，这类问题还可以进一步扩展，我们可以去解析类似HTML等标记语法， 比如检查XML标签是否闭合如何检查， 更进一步如果要你实现一个简单的XML的解析器，应该怎么实现？","content":"<!--\n * @File: \n * @Author: 张宏亮 - zhl@xiaoniren.cn\n * @Date: 2019-08-18 15:46:12\n * @LastEditors: 张宏亮<hongliang@yunshan.net>\n * @LastEditTime: 2019-09-22 16:03:00\n * @Description: file content\n * @Versions: 1.0.0\n -->\n<h3 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h3><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p>\n<p>有效字符串需满足：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">左括号必须用相同类型的右括号闭合。</span><br><span class=\"line\">左括号必须以正确的顺序闭合。</span><br><span class=\"line\">注意空字符串可被认为是有效字符串。</span><br></pre></td></tr></table></figure></p>\n<p>示例 1:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: &quot;()&quot;</span><br><span class=\"line\">输出: true</span><br></pre></td></tr></table></figure></p>\n<p>示例 2:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: &quot;()[]&#123;&#125;&quot;</span><br><span class=\"line\">输出: true</span><br></pre></td></tr></table></figure></p>\n<p>示例 3:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: &quot;(]&quot;</span><br><span class=\"line\">输出: false</span><br></pre></td></tr></table></figure></p>\n<p>示例 4:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: &quot;([)]&quot;</span><br><span class=\"line\">输出: false</span><br></pre></td></tr></table></figure></p>\n<p>示例 5:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: &quot;&#123;[]&#125;&quot;</span><br><span class=\"line\">输出: true</span><br></pre></td></tr></table></figure></p>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/valid-parentheses\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/valid-parentheses</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<p>标签 <strong>栈</strong> <strong>字符串</strong></p>\n<h3 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><ol>\n<li>如果括号数量为奇数，肯定是错误的</li>\n<li>如果括号数量为偶数，使用栈，遍历输入字符串</li>\n<li>如果当前字符为左半边括号时，肯定是正确的，将其压入栈中</li>\n<li>如果遇到右半边括号时，右半边括号与栈顶的左半括号不匹配，返回错误</li>\n<li>如果匹配，把匹配的左半括号弹出栈</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/zhl1232/javascript-algorithm/master/static/img/stack.png\" alt=\"image\"></p>\n<p>图片来自： <a href=\"https://github.com/MisterBooo/LeetCodeAnimation\" target=\"_blank\" rel=\"noopener\">https://github.com/MisterBooo/LeetCodeAnimation</a></p>\n<h3 id=\"解法一\"><a href=\"#解法一\" class=\"headerlink\" title=\"解法一\"></a>解法一</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;string&#125;</span> <span class=\"variable\">s</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return <span class=\"type\">&#123;boolean&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> isValid = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">s</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> sArr = s.split(<span class=\"string\">''</span>)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> temp = []</span><br><span class=\"line\">    <span class=\"keyword\">let</span> res = <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(sArr.length % <span class=\"number\">2</span> == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      sArr.forEach(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (item.match(<span class=\"regexp\">/\\(|\\&#123;|\\[/</span>)) &#123;</span><br><span class=\"line\">          temp.push(item)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (item == <span class=\"string\">')'</span> &amp;&amp; temp.pop() == <span class=\"string\">'('</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (item == <span class=\"string\">'&#125;'</span> &amp;&amp; temp.pop() == <span class=\"string\">'&#123;'</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (item == <span class=\"string\">']'</span> &amp;&amp; temp.pop() == <span class=\"string\">'['</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            res = <span class=\"literal\">false</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>()</span><br><span class=\"line\">            <span class=\"comment\">// 如果为false，用try catch跳出循环</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (error) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (temp.length == <span class=\"number\">0</span> &amp;&amp; res) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>js没有现成的栈，用数组模拟<br>可以用 try catch 跳出 forEach 循环</p>\n</blockquote>\n<p>这道题写法可能各不相同，但解题逻辑只有这一种。</p>\n<p>比如写法可以把每对括号存hash表里，然后匹配的时候用 key: value 匹配对应的括号</p>\n<p>或者用for循环，跳出和return容易很多。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> hash = &#123; <span class=\"string\">')'</span>: <span class=\"string\">'('</span>, <span class=\"string\">'&#125;'</span>: <span class=\"string\">'&#123;'</span>, <span class=\"string\">']'</span>: <span class=\"string\">'['</span> &#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h3><p>事实上，这类问题还可以进一步扩展，我们可以去解析类似HTML等标记语法， 比如检查XML标签是否闭合如何检查， 更进一步如果要你实现一个简单的XML的解析器，应该怎么实现？</p>\n"},{"title":"leetcode.11.有效的括号","text":"题目描述给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且 n 的值至少为 2。 图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 示例:12输入: [1,8,6,2,5,4,8,3,7]输出: 49 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/container-with-most-water著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 标签 数组 双指针 解题思路设置对撞指针 left，right，每次选两指针中的短板向中间移动1格，并且更新面积最大值 res，直到 i == j 时返回 res。 至于为什么移动短的指针不会漏掉最优解，下面这个是大神写的正确性证明。 11题双指针正确性证明 下面这个可能容易理解点 原面积s = h(i) * w 如果移动 j, 有两种肩况 移动后 j’ 的高度比i 高, s’= h(i) * (w-l) &lt; s 移动后 j’ 的高度比i 低, s’= h(j’) * (w-l) &lt; s 两种情况下, 移动后的面积s 都会小于s所以可证， 只有移动较短边才有可能面积更大 解法一：双指针1234567891011121314151617181920/** * @param &#123;number[]&#125; height * @return &#123;number&#125; */var maxArea = function(height) &#123; let res = 0 let left = 0 let right = height.length - 1 while(left &lt; right) &#123; let h = Math.min(height[left], height[right]) let w = right - left res = Math.max(h * w, res) if(height[left] &lt; height[right]) &#123; left++ &#125; else &#123; right-- &#125; &#125; return res&#125;;","content":"<h3 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h3><p>给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>\n<p>说明：你不能倾斜容器，且 n 的值至少为 2。</p>\n<p><img src=\"https://raw.githubusercontent.com/zhl1232/javascript-algorithm/master/static/img/11.jpg\" alt=\"image\"></p>\n<p>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p>\n<p>示例:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [1,8,6,2,5,4,8,3,7]</span><br><span class=\"line\">输出: 49</span><br></pre></td></tr></table></figure></p>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/container-with-most-water\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/container-with-most-water</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<p>标签 <strong>数组</strong> <strong>双指针</strong></p>\n<h3 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>设置对撞指针 left，right，每次选两指针中的短板向中间移动1格，并且更新面积最大值 res，直到 i == j 时返回 res。</p>\n<p>至于为什么移动短的指针不会漏掉最优解，下面这个是大神写的正确性证明。</p>\n<p><a href=\"https://leetcode-cn.com/problems/container-with-most-water/solution/shuang-zhi-zhen-fa-zheng-que-xing-zheng-ming-by-r3/\" target=\"_blank\" rel=\"noopener\">11题双指针正确性证明</a></p>\n<p>下面这个可能容易理解点</p>\n<p><img src=\"https://raw.githubusercontent.com/zhl1232/javascript-algorithm/master/static/img/11-1.png\" alt=\"image\"></p>\n<ol>\n<li>原面积s = h(i) * w</li>\n<li>如果移动 j, 有两种肩况</li>\n<li>移动后 j’ 的高度比i 高, s’= h(i) * (w-l) &lt; s</li>\n<li>移动后 j’ 的高度比i 低, s’= h(j’) * (w-l) &lt; s</li>\n<li>两种情况下, 移动后的面积s 都会小于s<br>所以可证， 只有移动较短边才有可能面积更大</li>\n</ol>\n<h3 id=\"解法一：双指针\"><a href=\"#解法一：双指针\" class=\"headerlink\" title=\"解法一：双指针\"></a>解法一：双指针</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;number[]&#125;</span> <span class=\"variable\">height</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return <span class=\"type\">&#123;number&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> maxArea = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">height</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> res = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> left = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> right = height.length - <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(left &lt; right) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> h = <span class=\"built_in\">Math</span>.min(height[left], height[right])</span><br><span class=\"line\">        <span class=\"keyword\">let</span> w = right - left</span><br><span class=\"line\">        res = <span class=\"built_in\">Math</span>.max(h * w, res)</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(height[left] &lt; height[right]) &#123;</span><br><span class=\"line\">            left++</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            right--</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n"},{"title":"404","text":"","content":""}],"categories":[],"tags":[]}