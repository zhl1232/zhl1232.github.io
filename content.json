[{"title":"test","date":"2021-02-20T10:38:06.067Z","path":"2021/02/20/test/index/","text":"ECharts // 基于准备好的dom，初始化echarts实例 var myChart = echarts.init(document.getElementById('main')); // 指定图表的配置项和数据 var option = { title: { text: 'ECharts 入门示例' }, tooltip: {}, legend: { data:['销量'] }, xAxis: { data: [\"衬衫\",\"羊毛衫\",\"雪纺衫\",\"裤子\",\"高跟鞋\",\"袜子\"] }, yAxis: {}, series: [{ name: '销量', type: 'bar', data: [5, 20, 36, 10, 10, 20] }] }; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); L2Dwidget.init({\"pluginRootPath\":\"live2dw/\",\"pluginJsPath\":\"lib/\",\"pluginModelPath\":\"assets/\",\"tagMode\":false,\"log\":false,\"model\":{\"jsonPath\":\"/live2dw/assets/assets/haru01.model.json\"},\"display\":{\"position\":\"right\",\"width\":150,\"height\":300},\"mobile\":{\"show\":true}});","tags":[]},{"title":"leetcode.1047.删除字符串中的所有相邻重复项","date":"2020-07-19T06:13:35.000Z","path":"2020/07/19/leetcode-1047-删除字符串中的所有相邻重复项/","text":"","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"栈","slug":"栈","permalink":"http://yoursite.com/tags/栈/"},{"name":"字符串","slug":"字符串","permalink":"http://yoursite.com/tags/字符串/"}]},{"title":"leetcode.961-重复N次的元素","date":"2020-07-19T06:13:24.000Z","path":"2020/07/19/leetcode-961-重复N次的元素/","text":"题目描述在大小为 2N 的数组 A 中有 N+1 个不同的元素，其中有一个元素重复了 N 次。 返回重复了 N 次的那个元素。 示例 1：12输入：[1,2,3,3]输出：3 示例 2：12输入：[2,1,2,5,3,2]输出：2 示例 3：12输入：[5,1,5,2,5,3,5,4]输出：5 提示：1234 &lt;= A.length &lt;= 100000 &lt;= A[i] &lt; 10000A.length 为偶数 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/n-repeated-element-in-size-2n-array著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 标签 哈希表 解题思路数组大小2N，一共 N+1 个元素，目标元素出现N次，说明其他元素只出现一次。 新建一个空的哈希表，遍历数组，如果当前元素出现2次，该元素为目标元素。 1234567891011121314/** * @param &#123;number[]&#125; A * @return &#123;number&#125; */var repeatedNTimes = function(A) &#123; let hash = new Map() for(num of A) &#123; if(hash.has(num)) &#123; return num &#125; else &#123; hash.set(num, 1) &#125; &#125;&#125;;","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"简单","slug":"简单","permalink":"http://yoursite.com/tags/简单/"},{"name":"哈希表","slug":"哈希表","permalink":"http://yoursite.com/tags/哈希表/"}]},{"title":"leetcode.832.翻转图像","date":"2020-07-19T06:13:15.000Z","path":"2020/07/19/leetcode-832-翻转图像/","text":"题目描述给定一个二进制矩阵 A，我们想先水平翻转图像，然后反转图像并返回结果。 水平翻转图片就是将图片的每一行都进行翻转，即逆序。例如，水平翻转 [1, 1, 0] 的结果是 [0, 1, 1]。 反转图片的意思是图片中的 0 全部被 1 替换， 1 全部被 0 替换。例如，反转 [0, 1, 1] 的结果是 [1, 0, 0]。 示例 1:1234输入: [[1,1,0],[1,0,1],[0,0,0]]输出: [[1,0,0],[0,1,0],[1,1,1]]解释: 首先翻转每一行: [[0,1,1],[1,0,1],[0,0,0]]； 然后反转图片: [[1,0,0],[0,1,0],[1,1,1]] 示例 2:1234输入: [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]输出: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]解释: 首先翻转每一行: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]； 然后反转图片: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]] 说明:121 &lt;= A.length = A[0].length &lt;= 200 &lt;= A[i][j] &lt;= 1 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/flipping-an-image著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 标签 数组 方法一：数组API没啥说的。。1234567/** * @param &#123;number[][]&#125; A * @return &#123;number[][]&#125; */var flipAndInvertImage = function(A) &#123; return A.map(item =&gt; item.reverse().map(item1 =&gt; item1 === 0 ? 1 : 0))&#125;; 方法二：对撞双指针按位异或： 参与运算的两个值，如果两个相应位相同，则结果为0，否则为1。即：0^0=0， 1^0=1， 0^1=1， 1^1=0 所以 (0 和 1) ^ 1 就会相当于反转，1 会变成 0， 0 会变成 1。当然用三元运算符也行。 利用双指针，把右边的值反转放到左边，把左边的值反转放到右边。 就相当于翻转并反转了。 1234567891011121314151617181920/** * @param &#123;number[][]&#125; A * @return &#123;number[][]&#125; */var flipAndInvertImage = function(A) &#123; for (let i = 0; i &lt; A.length; i++) &#123; let left = 0 let right = A.length - 1 while (left &lt;= right) &#123; let temp = A[i][left] A[i][left] = A[i][right] ^ 1 A[i][right] = temp ^ 1 // A[i][left] = A[i][right] === 1 ? 0 : 1 // A[i][right] = temp === 1 ? 0 : 1 left++ right-- &#125; &#125; return A&#125; 方法三：规律比如 [1,1,0]，水平翻转后是[0,1,1]，再反转就会变为 [1,0,0]。 比如 [1,1,0,0]，水平翻转后是[0,0,1,1]，再反转就会变为 [1,1,0,0]. 会发现，两边的值只要不相等，水平翻转后再反转就会和之前一样。奇数长度中间值没法比较的一会再说。 再看两边值相等的，最后结果就是原来的值取反。 最后再看奇数长度中间值，发现都是取反。 所以只要判断对撞指针两边的值是否相等，如果相等，值不变。如果不相等值取反。如果是奇数，那把中间值也取反。 123456789101112131415161718192021222324/** * @param &#123;number[][]&#125; A * @return &#123;number[][]&#125; */var flipAndInvertImage = function(A) &#123; let n = A.length for (let i = 0; i &lt; n; i++) &#123; let left = 0 let right = n - 1 while (left &lt; right) &#123; if (A[i][left] === A[i][right]) &#123; A[i][left] = A[i][left] ^ 1 A[i][right] = A[i][right] ^ 1 &#125; left++ right-- &#125; if (n % 2) &#123; A[i][~~(n / 2)] = A[i][~~(n / 2)] ^ 1 &#125; &#125; return A&#125;","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"简单","slug":"简单","permalink":"http://yoursite.com/tags/简单/"}]},{"title":"leetcode.811.子域名访问计数","date":"2020-07-19T06:13:07.000Z","path":"2020/07/19/leetcode-811-子域名访问计数/","text":"题目描述一个网站域名，如”discuss.leetcode.com”，包含了多个子域名。作为顶级域名，常用的有”com”，下一级则有”leetcode.com”，最低的一级为”discuss.leetcode.com”。当我们访问域名”discuss.leetcode.com”时，也同时访问了其父域名”leetcode.com”以及顶级域名 “com”。 给定一个带访问次数和域名的组合，要求分别计算每个域名被访问的次数。其格式为访问次数+空格+地址，例如：”9001 discuss.leetcode.com”。 接下来会给出一组访问次数和域名组合的列表cpdomains 。要求解析出所有域名的访问次数，输出格式和输入格式相同，不限定先后顺序。 示例 1:1234输入: [&quot;9001 discuss.leetcode.com&quot;]输出: [&quot;9001 discuss.leetcode.com&quot;, &quot;9001 leetcode.com&quot;, &quot;9001 com&quot;] 说明:1例子中仅包含一个网站域名：&quot;discuss.leetcode.com&quot;。按照前文假设，子域名&quot;leetcode.com&quot;和&quot;com&quot;都会被访问，所以它们都被访问了9001次。 示例 21234输入: [&quot;900 google.mail.com&quot;, &quot;50 yahoo.com&quot;, &quot;1 intel.mail.com&quot;, &quot;5 wiki.org&quot;]输出: [&quot;901 mail.com&quot;,&quot;50 yahoo.com&quot;,&quot;900 google.mail.com&quot;,&quot;5 wiki.org&quot;,&quot;5 org&quot;,&quot;1 intel.mail.com&quot;,&quot;951 com&quot;] 说明:12按照假设，会访问&quot;google.mail.com&quot; 900次，&quot;yahoo.com&quot; 50次，&quot;intel.mail.com&quot; 1次，&quot;wiki.org&quot; 5次。而对于父域名，会访问&quot;mail.com&quot; 900+1 = 901次，&quot;com&quot; 900 + 50 + 1 = 951次，和 &quot;org&quot; 5 次。 注意事项：1234cpdomains 的长度小于 100。每个域名的长度小于100。每个域名地址包含一个或两个&quot;.&quot;符号。输入中任意一个域名的访问次数都小于10000。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/subdomain-visit-count著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 标签 哈希表 解题思路 将 “900 google.mail.com” 拆成次数 num 900 和 url ‘google.mail.com’ 再把 url 按 ‘.’ 拆开，每级域名访问次数都是 num 900[‘google.mail.com’, ‘mail.com’, ‘com’] 遍历数组，把拆分的子域名存到哈希表里 key-&gt;域名 value-&gt;num，如果哈希表里有就把哈希表里的 num 和现在的 num 相加 拼接返回值123456789101112131415161718192021222324252627282930/** * @param &#123;string[]&#125; cpdomains * @return &#123;string[]&#125; */var subdomainVisits = function(cpdomains) &#123; let map = new Map() let res = [] for(let i = 0; i &lt; cpdomains.length; i++) &#123; let [num, url] = cpdomains[i].split(' ') while(url.includes('.'))&#123; if(map.has(url))&#123; map.set(url, (Number(map.get(url)) + Number(num))) &#125; else &#123; map.set(url, num) &#125; url = url.slice(url.indexOf('.') + 1) &#125; if(map.has(url))&#123; map.set(url, (Number(map.get(url)) + Number(num))) &#125; else &#123; map.set(url, num) &#125; &#125; map.forEach((value, key) =&gt; &#123; res.push(`$&#123;value&#125; $&#123;key&#125;`) &#125;) return res&#125;;","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"简单","slug":"简单","permalink":"http://yoursite.com/tags/简单/"},{"name":"哈希表","slug":"哈希表","permalink":"http://yoursite.com/tags/哈希表/"}]},{"title":"leetcode.771.宝石与石头","date":"2020-07-19T06:13:00.000Z","path":"2020/07/19/leetcode-771-宝石与石头/","text":"题目描述 给定字符串J 代表石头中宝石的类型，和字符串 S代表你拥有的石头。 S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。 J 中的字母不重复，J 和 S中的所有字符都是字母。字母区分大小写，因此”a”和”A”是不同类型的石头。 示例 1:12输入: J = &quot;aA&quot;, S = &quot;aAAbbbb&quot;输出: 3 示例 2:12输入: J = &quot;z&quot;, S = &quot;ZZ&quot;输出: 0 注意: S 和 J 最多含有50个字母。 J 中的字符不重复。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/jewels-and-stones著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 标签 哈希表 标准的哈希集合题目，没啥说的。。123456789101112131415/** * @param &#123;string&#125; J * @param &#123;string&#125; S * @return &#123;number&#125; */var numJewelsInStones = function(J, S) &#123; let setJ = new Set(J) let res = 0 for(i = 0; i &lt; S.length; i++) &#123; if(setJ.has(S[i])) &#123; res += 1 &#125; &#125; return res&#125;;","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"简单","slug":"简单","permalink":"http://yoursite.com/tags/简单/"},{"name":"哈希表","slug":"哈希表","permalink":"http://yoursite.com/tags/哈希表/"}]},{"title":"leetcode.739.每日温度","date":"2020-07-19T06:12:53.000Z","path":"2020/07/19/leetcode-739-每日温度/","text":"题目描述根据每日 气温 列表，请重新生成一个列表，对应位置的输入是你需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。 例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。 提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/daily-temperatures著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 标签 栈 哈希表 解法一：暴力法学算法之前的方法 12345678910111213141516171819202122232425262728/** * @param &#123;number[]&#125; T * @return &#123;number[]&#125; */var dailyTemperatures = function(T) &#123; let res = [] for(let i = 1; i &lt; T.length; i++) &#123; let stack = [T[i-1]] if(stack[0] &gt;= T[i]) &#123; let j = i while(stack[0] &gt;= T[j] &amp;&amp; j &lt;= T.length)&#123; stack.push(T[j]) j++ &#125; if(stack[0] &lt;= T[j] &amp;&amp; j &lt;= T.length) &#123; res.push(stack.length) &#125; else if(j =&gt; T.length ) &#123; res.push(0) &#125; &#125; else &#123; res.push(stack.length) &#125; &#125; res.push(0) return res&#125;; 解法二：单调递增栈先说单调栈， 单调栈就是栈内元素保持一定单调性（单调递增或单调递减）的栈。这里的单调递增或递减是指的从栈顶到栈底单调递增或递减。既然是栈，就满足后进先出的特点。 例如，现在有一个数组 [3, 4, 2, 6, 4, 5, 2, 3]，从左到右依次入栈，单调递增栈的实现。 1234567891011// 单调递增栈的实现let arr = [3, 4, 2, 6, 4, 5, 2, 3]let res = []for (let i = 0; i &lt; arr.length; i++) &#123; while (res.length &amp;&amp; res[res.length - 1] &lt; arr[i]) &#123; res.pop() &#125; res.push(arr[i])&#125;console.log(res) // [6, 5, 3] 将破坏栈单调性的元素都出栈，结果从栈顶到栈底单调递增或者递减。 了解了单调栈之后，再来看这道题。 维护一个单调递增栈，栈内存储气温数组 T 的 index 查看当前元素是否大于栈顶元素所对应的 T 的值，也就是 T[stack[stack.length - 1]] 如果大于，那说明找到需要等待的天数。如果不大于那说明还没到找到比这天高的温度。同时继续维护这个单调栈 如果大于，需要等待的天数就是当前数组 T 的下标减去单调栈顶对应的下标 循环完毕，还没有找到需要等待的天数，为0 12345678910111213141516171819/** * @param &#123;number[]&#125; T * @return &#123;number[]&#125; */var dailyTemperatures = function(T) &#123; let &#123; length &#125; = T let res = new Array(length).fill(0) let stack = [] for(let i = 0; i &lt; length; i++) &#123; while(stack.length &amp;&amp; T[i] &gt; T[stack[stack.length - 1]]) &#123; let index = stack.pop() res[index] = i - index &#125; stack.push(i) &#125; return res&#125;; 解法三： 占坑","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"栈","slug":"栈","permalink":"http://yoursite.com/tags/栈/"},{"name":"中等","slug":"中等","permalink":"http://yoursite.com/tags/中等/"},{"name":"哈希表","slug":"哈希表","permalink":"http://yoursite.com/tags/哈希表/"}]},{"title":"leetcode.706.设计哈希映射","date":"2020-07-19T06:12:46.000Z","path":"2020/07/19/leetcode-706-设计哈希映射/","text":"题目描述不使用任何内建的哈希表库设计一个哈希集合 具体地说，你的设计应该包含以下的功能 add(value)：向哈希集合中插入一个值。 contains(value) ：返回哈希集合中是否存在这个值。 emove(value)：将给定值从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。 示例:123456789MyHashSet hashSet = new MyHashSet();hashSet.add(1); hashSet.add(2); hashSet.contains(1); // 返回 truehashSet.contains(3); // 返回 false (未找到)hashSet.add(2); hashSet.contains(2); // 返回 truehashSet.remove(2); hashSet.contains(2); // 返回 false (已经被删除) 注意： 所有的值都在 [1, 1000000]的范围内。 操作的总数目在[1, 10000]范围内。 不要使用内建的哈希集合库。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/design-hashset著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 标签 设计 哈希表 js的对象本来就是哈希结构，而且也没涉及哈希函数的处理，没啥说的。。。 哈希函数的处理和封装，占坑，后补。 123456789101112131415161718192021222324252627282930313233343536373839/** * Initialize your data structure here. */var MyHashSet = function() &#123; this.hash = &#123;&#125;&#125;;/** * @param &#123;number&#125; key * @return &#123;void&#125; */MyHashSet.prototype.add = function(key) &#123; this.hash[key] = key&#125;;/** * @param &#123;number&#125; key * @return &#123;void&#125; */MyHashSet.prototype.remove = function(key) &#123; delete this.hash[key]&#125;;/** * Returns true if this set contains the specified element * @param &#123;number&#125; key * @return &#123;boolean&#125; */MyHashSet.prototype.contains = function(key) &#123; return (this.hash[key] != null)&#125;;/** * Your MyHashSet object will be instantiated and called as such: * var obj = new MyHashSet() * obj.add(key) * obj.remove(key) * var param_3 = obj.contains(key) */","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"简单","slug":"简单","permalink":"http://yoursite.com/tags/简单/"},{"name":"设计","slug":"设计","permalink":"http://yoursite.com/tags/设计/"},{"name":"哈希表","slug":"哈希表","permalink":"http://yoursite.com/tags/哈希表/"}]},{"title":"leetcode.705.设计哈希集合","date":"2020-07-19T06:12:39.000Z","path":"2020/07/19/leetcode-705-设计哈希集合/","text":"题目描述不使用任何内建的哈希表库设计一个哈希集合 具体地说，你的设计应该包含以下的功能 add(value)：向哈希集合中插入一个值。 contains(value) ：返回哈希集合中是否存在这个值。 emove(value)：将给定值从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。 示例:123456789MyHashSet hashSet = new MyHashSet();hashSet.add(1); hashSet.add(2); hashSet.contains(1); // 返回 truehashSet.contains(3); // 返回 false (未找到)hashSet.add(2); hashSet.contains(2); // 返回 truehashSet.remove(2); hashSet.contains(2); // 返回 false (已经被删除) 注意： 所有的值都在 [1, 1000000]的范围内。 操作的总数目在[1, 10000]范围内。 不要使用内建的哈希集合库。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/design-hashset著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 标签 设计 哈希表 js的对象本来就是哈希结构，而且也没涉及哈希函数的处理，没啥说的。。。 哈希函数的处理和封装，占坑，后补。 123456789101112131415161718192021222324252627282930313233343536373839/** * Initialize your data structure here. */var MyHashSet = function() &#123; this.hash = &#123;&#125;&#125;;/** * @param &#123;number&#125; key * @return &#123;void&#125; */MyHashSet.prototype.add = function(key) &#123; this.hash[key] = key&#125;;/** * @param &#123;number&#125; key * @return &#123;void&#125; */MyHashSet.prototype.remove = function(key) &#123; delete this.hash[key]&#125;;/** * Returns true if this set contains the specified element * @param &#123;number&#125; key * @return &#123;boolean&#125; */MyHashSet.prototype.contains = function(key) &#123; return (this.hash[key] != null)&#125;;/** * Your MyHashSet object will be instantiated and called as such: * var obj = new MyHashSet() * obj.add(key) * obj.remove(key) * var param_3 = obj.contains(key) */","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"简单","slug":"简单","permalink":"http://yoursite.com/tags/简单/"},{"name":"设计","slug":"设计","permalink":"http://yoursite.com/tags/设计/"},{"name":"哈希表","slug":"哈希表","permalink":"http://yoursite.com/tags/哈希表/"}]},{"title":"leetcode.648.单词替换","date":"2020-07-19T06:12:26.000Z","path":"2020/07/19/leetcode-648-单词替换/","text":"题目描述在英语中，我们有一个叫做 词根(root)的概念，它可以跟着其他一些词组成另一个较长的单词——我们称这个词为 继承词(successor)。例如，词根an，跟随着单词 other(其他)，可以形成新的单词 another(另一个)。 现在，给定一个由许多词根组成的词典和一个句子。你需要将句子中的所有继承词用词根替换掉。如果继承词有许多可以形成它的词根，则用最短的词根替换它。 你需要输出替换之后的句子。 示例 1:123输入: dict(词典) = [&quot;cat&quot;, &quot;bat&quot;, &quot;rat&quot;]sentence(句子) = &quot;the cattle was rattled by the battery&quot;输出: &quot;the cat was rat by the bat&quot; 注:12345输入只包含小写字母。1 &lt;= 字典单词数 &lt;=10001 &lt;= 句中词语数 &lt;= 10001 &lt;= 词根长度 &lt;= 1001 &lt;= 句中词语长度 &lt;= 1000 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/replace-words著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 标签 字典树 哈希表 解法一：没啥意义的直接解法时间复杂度O(n^2) 虽然没啥意义，不过结果看起来还不错。123执行结果：通过 显示详情执行用时 : 168 ms, 在所有 JavaScript 提交中击败了 91.67% 的用户内存消耗 : 40.7 MB, 在所有 JavaScript 提交中击败了 100.00% 的用户 1234567891011121314151617/** * @param &#123;string[]&#125; dict * @param &#123;string&#125; sentence * @return &#123;string&#125; */var replaceWords = function(dict, sentence) &#123; let words = sentence.split(' ') for(let i = 0; i &lt; words.length; i++) &#123; for(let j = 0; j &lt; dict.length; j++) &#123; if(words[i].startsWith(dict[j]))&#123; words[i] = dict[j] continue &#125; &#125; &#125; return words.join(' ')&#125;; 解法二：字典树开始用字母对应下标写的 children。 后来看到标签为字典树和哈希表。。 又改成哈希了。2333 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/** * @param &#123;string[]&#125; dict * @param &#123;string&#125; sentence * @return &#123;string&#125; *//** * Trie */class Trie &#123; constructor() &#123; this.root = new TrieNode(null) &#125; insertData(stringData) &#123; this.insert(stringData, this.root) &#125; insert(stringData, node) &#123; if (stringData == '') &#123; node.done = true return &#125; // 题目里都是单词，只有26个字母。用字母的 ASCII 码减 a 的 ASCII 码正好对应0-25 // const index = stringData[0].charCodeAt(0) - 'a'.charCodeAt(0) let haveData = node.children.get(stringData[0]) if (haveData) &#123; this.insert(stringData.substring(1), haveData) &#125; else &#123; let newNode = new TrieNode(stringData[0]) // node.children[index] = newNode node.children.set(stringData[0], newNode) this.insert(stringData.substring(1), newNode) &#125; &#125; search(stringData) &#123; let node = this.root let res = '' for (let i = 0; i &lt; stringData.length; i++) &#123; // cattle const element = stringData[i] // const index = element.charCodeAt(0) - 'a'.charCodeAt(0) const target = node.children.get(element) if (node.done) &#123; break &#125; else if (target) &#123; res += target.key node = target &#125; else &#123; res = '' break &#125; &#125; return res &#125;&#125;/** * 节点 * @param &#123;*&#125; key */class TrieNode &#123; constructor(key) &#123; this.key = key // 节点字符 this.children = new Map() // 子节点集合 &#125;&#125;var replaceWords = function(dict, sentence) &#123; const trie = new Trie(); for(let i = 0; i &lt; dict.length; i++) &#123; trie.insertData(dict[i]); &#125; return sentence.split(' ').map(wrod =&gt; trie.search(wrod) || wrod).join(' ');&#125;; 字典树资料","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"中等","slug":"中等","permalink":"http://yoursite.com/tags/中等/"},{"name":"哈希表","slug":"哈希表","permalink":"http://yoursite.com/tags/哈希表/"},{"name":"字典树","slug":"字典树","permalink":"http://yoursite.com/tags/字典树/"}]},{"title":"leetcode.599.两个列表的最小索引总和","date":"2020-07-19T06:12:06.000Z","path":"2020/07/19/leetcode-599-两个列表的最小索引总和/","text":"题目描述假设Andy和Doris想在晚餐时选择一家餐厅，并且他们都有一个表示最喜爱餐厅的列表，每个餐厅的名字用字符串表示。 你需要帮助他们用最少的索引和找出他们共同喜爱的餐厅。 如果答案不止一个，则输出所有答案并且不考虑顺序。 你可以假设总是存在一个答案。 示例 1:12345输入:[&quot;Shogun&quot;, &quot;Tapioca Express&quot;, &quot;Burger King&quot;, &quot;KFC&quot;][&quot;Piatti&quot;, &quot;The Grill at Torrey Pines&quot;, &quot;Hungry Hunter Steakhouse&quot;, &quot;Shogun&quot;]输出: [&quot;Shogun&quot;]解释: 他们唯一共同喜爱的餐厅是“Shogun”。 示例 2:12345输入:[&quot;Shogun&quot;, &quot;Tapioca Express&quot;, &quot;Burger King&quot;, &quot;KFC&quot;][&quot;KFC&quot;, &quot;Shogun&quot;, &quot;Burger King&quot;]输出: [&quot;Shogun&quot;]解释: 他们共同喜爱且具有最小索引和的餐厅是“Shogun”，它有最小的索引和1(0+1)。 提示: 两个列表的长度范围都在 [1, 1000]内。 两个列表中的字符串的长度将在[1，30]的范围内。 下标从0开始，到列表的长度减1。 两个列表都没有重复的元素。 标签 哈希表 https://leetcode-cn.com/problems/minimum-index-sum-of-two-lists/ 解题思路根据提示两个列表都没有重复的元素。所以两个列表同一餐厅最多出现两次。所以只要比较出现两次的餐厅的下标和就可以。如果下标和小就当作返回值，如果下标和相等，就push到返回值里。 123456789101112131415161718192021222324252627282930/** * @param &#123;string[]&#125; list1 * @param &#123;string[]&#125; list2 * @return &#123;string[]&#125; */var findRestaurant = function(list1, list2) &#123; let res = [] let indexSum let hash = new Map() for(let i = 0; i &lt; list1.length; i++) &#123; hash.set(list1[i], i) &#125; for(let i = 0; i &lt; list2.length; i++) &#123; if(hash.has(list2[i])) &#123; if(typeof indexSum === 'undefined') &#123; indexSum = hash.get(list2[i]) + i res = [list2[i]] &#125; else &#123; if(indexSum &gt; hash.get(list2[i]) + i) &#123; indexSum = hash.get(list2[i]) + i res = [list2[i]] &#125; else if(indexSum == hash.get(list2[i]) + i)&#123; res.push(list2[i]) &#125; &#125; &#125; &#125; return res&#125;;","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"简单","slug":"简单","permalink":"http://yoursite.com/tags/简单/"},{"name":"哈希表","slug":"哈希表","permalink":"http://yoursite.com/tags/哈希表/"}]},{"title":"leetcode.535.TinyURL的加密与解密","date":"2020-07-19T06:11:53.000Z","path":"2020/07/19/leetcode-535-TinyURL的加密与解密/","text":"题目描述TinyURL是一种URL简化服务， 比如：当你输入一个URL https://leetcode.com/problems/design-tinyurl 时，它将返回一个简化的URL http://tinyurl.com/4e9iAk. 要求：设计一个 TinyURL 的加密 encode 和解密 decode 的方法。你的加密和解密算法如何设计和运作是没有限制的，你只需要保证一个URL可以被加密成一个TinyURL，并且这个TinyURL可以用解密方法恢复成原本的URL。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/encode-and-decode-tinyurl著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 标签 哈希表 数学 短网址原理当我们在浏览器里输入 http://tinyurl.com/4e9iAk 时 DNS首先解析获得 http://tinyurl.com 的 IP 地址 当 DNS 获得 IP 地址以后（比如：74.125.225.72），会向这个地址发送 HTTP GET 请求，查询短码 4e9iAk http://t.cn 服务器会通过短码 4e9iAk 获取对应的长 URL 请求通过 HTTP 301 转到对应的长 URL https://leetcode.com/problems/design-tinyurl 。 301 是永久重定向，302 是临时重定向。短地址一经生成就不会变化，所以用 301 是符合 http 语义的。 短网址算法这道题的标签是 哈希表，数学。哈希表不用说了，肯定得把短网址映射到长网址上。 数学 网上比较流行的短网址算法有两种 自增序列算法、 摘要算法。 这里我们用自增序列算法，比较好理解。 设置 id 自增，一个 10进制 id 对应一个 62进制的数值，1对1，也就不会出现重复的情况。这个利用的就是低进制转化为高进制时，字符数会减少的特性。 短址的长度一般设为 6 位，总共会有 64^6 ~= 687亿种组合，基本上不会重复。 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Encodes a URL to a shortened URL. * * @param &#123;string&#125; longUrl * @return &#123;string&#125; */let hash = new Map()var encode = function(longUrl) &#123; let chars = '0123456789abcdefghigklmnopqrstuvwxyzABCDEFGHIGKLMNOPQRSTUVWXYZ-~'.split(''), radix = chars.length, qutient = 10000000000, arr = []; do &#123; mod = qutient % radix; qutient = (qutient - mod) / radix; arr.unshift(chars[mod]); &#125; while (qutient); hash.set(arr.join(''),longUrl) return 'http://tinyurl.com/' + arr.join('')&#125;;/** * Decodes a shortened URL to its original URL. * * @param &#123;string&#125; shortUrl * @return &#123;string&#125; */var decode = function(shortUrl) &#123; // var chars = '0123456789abcdefghigklmnopqrstuvwxyzABCDEFGHIGKLMNOPQRSTUVWXYZ-~', // radix = chars.length, // number_code = String(number_code), // len = number_code.length, // i = 0, // origin_number = 0; // while (i &lt; len) &#123; // origin_number += Math.pow(radix, i++) * chars.indexOf(number_code.charAt(len - i) || 0); // &#125; shortUrl = shortUrl.replace(/http:\\/\\/tinyurl\\.com\\//,'') return hash.get(shortUrl)&#125;;/** * Your functions will be called as such: * decode(encode(url)); */ 这种方法是设置一个 id ，然后对 id 进行编码，然后用编码后的 id 进行映射。 另一种摘要算法，是直接对 longUrl 编码。","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"中等","slug":"中等","permalink":"http://yoursite.com/tags/中等/"},{"name":"哈希表","slug":"哈希表","permalink":"http://yoursite.com/tags/哈希表/"},{"name":"数学","slug":"数学","permalink":"http://yoursite.com/tags/数学/"}]},{"title":"leetcode.500.键盘行","date":"2020-07-19T06:11:42.000Z","path":"2020/07/19/leetcode-500-键盘行/","text":"题目描述给定一个单词列表，只返回可以使用在键盘同一行的字母打印出来的单词。键盘如下图所示。 示例：12输入: [&quot;Hello&quot;, &quot;Alaska&quot;, &quot;Dad&quot;, &quot;Peace&quot;]输出: [&quot;Alaska&quot;, &quot;Dad&quot;] 注意：12你可以重复使用键盘上同一字符。你可以假设输入的字符串将只包含字母。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/keyboard-row著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 标签 哈希表 标签哈希表，建立好映射关系，每一行字母对应一个value。 然后遍历每个单词的每个字母是否在同一行，value 是否相同。 注意大小写。 123456789101112131415161718192021222324252627/** * @param &#123;string[]&#125; words * @return &#123;string[]&#125; */var findWords = function(words) &#123; let map = new Map([ ['q',1],['w',1],['e',1],['r',1],['t',1],['y',1],['u',1],['i',1],['o',1],['p',1], ['a',2],['s',2],['d',2],['f',2],['g',2],['h',2],['j',2],['k',2],['l',2], ['z',3],['x',3],['c',3],['v',3],['b',3],['n',3],['m',3] ]) let res = [] for(let i = 0; i &lt; words.length; i++) &#123; let word = words[i] let temp = map.get(word[0].toLowerCase()) for(let j = 0; j &lt; word.length; j++) &#123; if(temp == map.get(word[j].toLowerCase())) &#123; if (j == word.length - 1) &#123; res.push(word) &#125; &#125; else &#123; break &#125; &#125; &#125; return res&#125;;","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"简单","slug":"简单","permalink":"http://yoursite.com/tags/简单/"},{"name":"哈希表","slug":"哈希表","permalink":"http://yoursite.com/tags/哈希表/"}]},{"title":"leetcode.387.字符串中的第一个唯一字符","date":"2020-07-19T06:11:34.000Z","path":"2020/07/19/leetcode-387-字符串中的第一个唯一字符/","text":"题目描述给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。 案例:12345s = &quot;leetcode&quot;返回 0.s = &quot;loveleetcode&quot;,返回 2. 注意事项：您可以假定该字符串只包含小写字母。 标签 哈希表 字符串 https://leetcode-cn.com/problems/first-unique-character-in-a-string/ 解题思路这道题最优的解法就是线性复杂度了，为了保证每个元素是唯一的，至少得把每个字符都遍历一遍。 算法的思路就是遍历一遍字符串，然后把字符串中每个字符出现的次数保存在一个散列表中。这个过程的时间复杂度为 O(N)，其中 N 为字符串的长度。 接下来需要再遍历一次字符串，这一次利用散列表来检查遍历的每个字符是不是唯一的。如果当前字符唯一，直接返回当前下标就可以了。第二次遍历的时间复杂度也是 O(N)。 正常哈希表写法，但因为语言实现的原因，速度比较慢。12345678910111213141516171819202122/** * @param &#123;string&#125; s * @return &#123;number&#125; */var firstUniqChar = function(s) &#123; let hash = new Map() for(let i = 0; i &lt; s.length; i++) &#123; if(hash.has(s[i])) &#123; hash.set(s[i], hash.get(s[i]) + 1) &#125; else &#123; hash.set(s[i], 1) &#125; &#125; for(let i = 0; i &lt; s.length; i++) &#123; if(hash.get(s[i]) == 1)&#123; return i &#125; &#125; return -1&#125;; 语言自带字符串api实现。indexOf从左找出现第一个，lastIndexOf从右找出现第一个。 如果两个下标一样，那说明这个值就是唯一字符。 字符串是从左到右遍历的，所以只要indexOf和lastIndexOf的下标一样，那说明这个值就是字符串中的第一个唯一字符1234567891011121314/** * @param &#123;string&#125; s * @return &#123;number&#125; */var firstUniqChar = function(s) &#123; let temp for (let i = 0; i &lt; s.length; i++) &#123; temp = s[i] if (s.indexOf(temp) === i &amp;&amp; s.lastIndexOf(temp) === i) &#123; return i &#125; &#125; return -1&#125;;","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"字符串","slug":"字符串","permalink":"http://yoursite.com/tags/字符串/"},{"name":"简单","slug":"简单","permalink":"http://yoursite.com/tags/简单/"},{"name":"哈希表","slug":"哈希表","permalink":"http://yoursite.com/tags/哈希表/"}]},{"title":"leetcode.350.两个数组的交集II","date":"2020-07-19T06:11:25.000Z","path":"2020/07/19/leetcode-350-两个数组的交集II/","text":"题目描述给定两个数组，编写一个函数来计算它们的交集。 示例 1:12输入: nums1 = [1,2,2,1], nums2 = [2,2]输出: [2,2] 示例 2:12输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出: [4,9] 说明： 输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。 我们可以不考虑输出结果的顺序。 进阶: 如果给定的数组已经排好序呢？你将如何优化你的算法？ 如果 nums1 的大小比 nums2 小很多，哪种方法更优？ 如果 nums2 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？ 标签 排序 哈希表 双指针 二分查找 https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/ 解法一：哈希表时间复杂度O(n) 先用Hashmap记录第一个数组中的元素【放在key】，和出现的次数【放在value】。 然后再遍历第二个数组，如果找到对应元素，则添加这个元素到返回数组里。 如果value值大于1，HashMap中的value值减 1，表示已经找到一个相同的了。 如果value值等于1，则删除该元素。 12345678910111213141516171819202122232425262728293031/** * @param &#123;number[]&#125; nums1 * @param &#123;number[]&#125; nums2 * @return &#123;number[]&#125; */var intersect = function(nums1, nums2) &#123; let hash = new Map() let res = [] for(let i = 0; i &lt; nums1.length; i++) &#123; if(hash.has(nums1[i])) &#123; hash.set(nums1[i], hash.get(nums1[i]) + 1) &#125; else &#123; hash.set(nums1[i], 1) &#125; &#125; for(let i = 0; i &lt; nums2.length; i++) &#123; let temp = nums2[i] let hashKey = hash.get(temp) if(hash.has(temp)) &#123; res.push(temp) if(hashKey &gt; 1) &#123; hash.set(temp, hashKey - 1) &#125; else &#123; hash.delete(temp) &#125; &#125; &#125; return res&#125;; 解法二：双指针 两个数组排序 设定两个为0的指针，比较两个指针的元素是否相等 如果相等，元素push到返回值里，两个指针同时往前 如果不相等，元素小的指针往前 如果相等，那肯定比较过的元素就没用了，两个指针++ 如果不相等，那把元素小的数组指针++。 因为大元素可能在小元素数组里存在，但是小元素在大元素所在数组肯定不存在。因为已经排过序了。 进阶里的第一条，但这个也不确定是否算是优化。 123456789101112131415161718192021222324/** * @param &#123;number[]&#125; nums1 * @param &#123;number[]&#125; nums2 * @return &#123;number[]&#125; */var intersect = function(nums1, nums2) &#123; let p1 = 0 let p2 = 0 let res = [] nums1 = nums1.sort((a, b) =&gt; a - b) nums2 = nums2.sort((a, b) =&gt; a - b) while(p1 &lt; nums1.length &amp;&amp; p2 &lt; nums2.length) &#123; if(nums1[p1] == nums2[p2]) &#123; res.push(nums1[p1]) p1++ p2++ &#125; else if(nums1[p1] &lt; nums2[p2]) &#123; p1++ &#125; else &#123; p2++ &#125; &#125; return res&#125;; 解法三：暴力循环时间复杂度O(n^2) 遍历第一个数组，然后在第二个数组查找是否有当前元素。 如果有，把当前元素push进返回值。然后把第二个数组里该下标元素删除。 优化一下，可以遍历length短的那个数组，在length长的数组里查找。 对应进阶第二条。1234567891011121314/** * @param &#123;number[]&#125; nums1 * @param &#123;number[]&#125; nums2 * @return &#123;number[]&#125; */var intersect = function(nums1, nums2) &#123; let res = []; if (nums1.length &lt; nums2.length) [nums1, nums2] = [nums2, nums1]; for (let i = 0; i &lt; nums1.length; i++) &#123; let key = nums2.indexOf(nums1[i]); if (key !== -1) res.push(nums2.splice(key, 1)); &#125; return res;&#125;; 进阶第三条，只给了nums2的条件，没有给nums1的。 内存不够的话，只能一部分一部分的处理。但是是否已排序的条件也没给。 标签里的二分查找也没有思路，有大佬有想法的可以留言。","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"双指针","slug":"双指针","permalink":"http://yoursite.com/tags/双指针/"},{"name":"简单","slug":"简单","permalink":"http://yoursite.com/tags/简单/"},{"name":"二分查找","slug":"二分查找","permalink":"http://yoursite.com/tags/二分查找/"},{"name":"哈希表","slug":"哈希表","permalink":"http://yoursite.com/tags/哈希表/"},{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/排序/"}]},{"title":"leetcode.349.两个数组的交集","date":"2020-07-19T06:11:18.000Z","path":"2020/07/19/leetcode-349-两个数组的交集/","text":"题目描述给定两个数组，编写一个函数来计算它们的交集。 示例 1:12输入: nums1 = [1,2,2,1], nums2 = [2,2]输出: [2] 示例 2:12输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出: [9,4] 说明:12输出结果中的每个元素一定是唯一的。我们可以不考虑输出结果的顺序。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/intersection-of-two-arrays著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 标签 排序 哈希表 双指针 二分查找 解法一 哈希表时间复杂度：O(m+n) 利用哈希集合值唯一的特性。 12345678910111213141516/** * @param &#123;number[]&#125; nums1 * @param &#123;number[]&#125; nums2 * @return &#123;number[]&#125; */var intersection = function(nums1, nums2) &#123; let hash1 = new Set(nums1) let hash2 = new Set() for(let i = 0; i &lt; nums2.length; i++) &#123; if(hash1.has(nums2[i]))&#123; hash2.add(nums2[i]) &#125; &#125; return [...hash2]&#125;; 解法二 双指针，排序因为标签里有双指针和排序就尝试了下。 执行时间会很长，排序后把数组先去重会好一点。123456789101112131415161718192021222324/** * @param &#123;number[]&#125; nums1 * @param &#123;number[]&#125; nums2 * @return &#123;number[]&#125; */var intersection = function(nums1, nums2) &#123; nums1 = nums1.sort((a,b) =&gt; a - b) nums2 = nums2.sort((a,b) =&gt; a - b) let p1 = p2 = 0 let res = new Set() while(p1 &lt; nums1.length &amp;&amp; p2 &lt; nums2.length) &#123; if(nums1[p1] &lt; nums2[p2]) &#123; p1++ &#125; else if(nums1[p1] == nums2[p2])&#123; res.add(nums1[p1]) p1++ p2++ &#125; else &#123; p2++ &#125; &#125; return [...res]&#125;; 解法三: 数组api12345678/** * @param &#123;number[]&#125; nums1 * @param &#123;number[]&#125; nums2 * @return &#123;number[]&#125; */var intersection = function(nums1, nums2) &#123; return [...new Set(nums1.filter(v =&gt; nums2.includes(v)))]&#125;;","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"双指针","slug":"双指针","permalink":"http://yoursite.com/tags/双指针/"},{"name":"简单","slug":"简单","permalink":"http://yoursite.com/tags/简单/"},{"name":"二分查找","slug":"二分查找","permalink":"http://yoursite.com/tags/二分查找/"},{"name":"哈希表","slug":"哈希表","permalink":"http://yoursite.com/tags/哈希表/"},{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/排序/"}]},{"title":"leetcode.345.反转字符串中的元音字母","date":"2020-07-19T06:11:06.000Z","path":"2020/07/19/leetcode-345-反转字符串中的元音字母/","text":"题目描述给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 说明：本题中，我们将空字符串定义为有效的回文串。 示例 1:12输入: &quot;A man, a plan, a canal: Panama&quot;输出: true 示例 2:12输入: &quot;race a car&quot;输出: false 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/valid-palindrome著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 标签 双指针 字符串 解题思路 用对撞指针，查看两指针是否为 ieaou 如两指针都是，交换，两指针都向中间移动 如果其中一指针不是，该指针向中间移动，直到 2 或者循环条件结束 解题方法123456789101112131415161718192021222324/** * @param &#123;string&#125; s * @return &#123;string&#125; */var reverseVowels = function(s) &#123; let reg = /[ieaou]/i let left = 0; let right = s.length - 1; // 为了交换方便，也可以用其他方法交换 let arr = s.split('') while(left &lt; right) &#123; if(reg.test(arr[left]) &amp;&amp; reg.test(arr[right])) &#123; [arr[left], arr[right]] = [arr[right], arr[left]] left++ right-- &#125; else if(!reg.test(arr[left])) &#123; left++ &#125; else if(!reg.test(arr[right])) &#123; right-- &#125; &#125; return arr.join('')&#125;;","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"字符串","slug":"字符串","permalink":"http://yoursite.com/tags/字符串/"},{"name":"双指针","slug":"双指针","permalink":"http://yoursite.com/tags/双指针/"},{"name":"简单","slug":"简单","permalink":"http://yoursite.com/tags/简单/"}]},{"title":"leetcode.344.反转字符串","date":"2020-07-19T06:10:58.000Z","path":"2020/07/19/leetcode-344-反转字符串/","text":"题目描述编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。 不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。 你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。 示例 1：12输入：[&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;] 示例 2：12输入：[&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/reverse-string著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 标签 双指针 字符串 解题思路经典的对撞指针题目，设置首尾两个指针，相互交换元素，两个指针向中间移动。 然后直到两个指针相遇。 解题方法12345678910111213/** * @param &#123;character[]&#125; s * @return &#123;void&#125; Do not return anything, modify s in-place instead. */var reverseString = function(s) &#123; let right = 0 let left = s.length - 1 while(right &lt; left) &#123; [s[right], s[left]] = [s[left], s[right]] right++ left-- &#125;&#125;; 递归写法1234567891011121314/** * @param &#123;character[]&#125; s * @return &#123;void&#125; Do not return anything, modify s in-place instead. */var reverseString = function(s) &#123; let seed = ~~(s.length / 2) swap(seed, s)&#125;;var swap = function(seed, s) &#123; if(seed &gt; 0) &#123; [s[seed - 1], s[s.length-seed]] = [s[s.length-seed], s[seed - 1]] swap(--seed, s) &#125;&#125;","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"字符串","slug":"字符串","permalink":"http://yoursite.com/tags/字符串/"},{"name":"双指针","slug":"双指针","permalink":"http://yoursite.com/tags/双指针/"},{"name":"简单","slug":"简单","permalink":"http://yoursite.com/tags/简单/"}]},{"title":"leetcode.283.移动零","date":"2020-07-19T06:10:51.000Z","path":"2020/07/19/leetcode-283-移动零/","text":"题目描述给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 示例:12输入: [0,1,0,3,12]输出: [1,3,12,0,0] 说明: 必须在原数组上操作，不能拷贝额外的数组。 尽量减少操作次数。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/move-zeroes著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 标签 双指针 数组 解题思路解法一：数组API 时间复杂度O(N) 对数组 API 熟悉，遍历数组，如果是 0 ，直接操作移到数组末尾。 12345678910111213141516/** * @param &#123;number[]&#125; nums * @return &#123;void&#125; Do not return anything, modify nums in-place instead. */var moveZeroes = function(nums) &#123; let temp = 0 for(let i = 0; i &lt; nums.length; i++) &#123; if(nums[temp] === 0) &#123; nums.splice(temp, 1) nums[nums.length] = 0 &#125; else &#123; temp++ &#125; &#125;&#125;; 方法二：双指针/初始定义 首先遍历一遍数列，用另个数列按顺序存储所有非 0 的元素，在将存储的非零元素按顺序复制到原数列中，空位补 0 即可。 直观的解题思路需要新建额外的数组，不符合要求，但是对于我们下面的优化算法很有起始。 只要把数组中所有的非零元素，按顺序给数组的前段元素位赋值，剩下的全部直接赋值 0。我们定义一个初始变量，为非 0 元素的数组下标，之后在遍历数列的时候不断维护这个定义。 12345678910111213141516/** * @param &#123;number[]&#125; nums * @return &#123;void&#125; Do not return anything, modify nums in-place instead. */var moveZeroes = function(nums) &#123; let lastNotZero = 0 for(let i = 0; i &lt; nums.length; i++) &#123; if(nums[i]) &#123; nums[lastNotZero++] = nums[i] &#125; &#125; for(let i = lastNotZero; i &lt; nums.length; i++) &#123; nums[i] = 0 &#125;&#125;;","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"双指针","slug":"双指针","permalink":"http://yoursite.com/tags/双指针/"},{"name":"简单","slug":"简单","permalink":"http://yoursite.com/tags/简单/"}]},{"title":"leetcode.219.存在重复元素II","date":"2020-07-19T06:10:43.000Z","path":"2020/07/19/leetcode-219-存在重复元素II/","text":"题目描述给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的绝对值最大为 k。 示例 1:12输入: nums = [1,2,3,1], k = 3输出: true 示例 2:12输入: nums = [1,0,1,1], k = 1输出: true 示例 3:12输入: nums = [1,2,3,1,2,3], k = 2输出: false 标签 哈希表 数组 https://leetcode-cn.com/problems/contains-duplicate-ii/ 解题思路时间复杂度O(n) 遍历数组，如果当前值不存在hash表里，把值-&gt;key,下标-&gt;value,存进hash表 如果当前值在hash表里存在，看下两个值下标的绝对值是否 &lt;= k 如果 &lt;= k，返回true 否则，更新当前值的下标。因为之前的都不成功，如果有下一个相同元素的话绝对值会更大。 循环完成还没有匹配成功，返回false 123456789101112131415161718192021/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; k * @return &#123;boolean&#125; */var containsNearbyDuplicate = function(nums, k) &#123; let hash = new Map() for(let i = 0; i &lt; nums.length; i++) &#123; if(hash.has(nums[i])) &#123; if(Math.abs(hash.get(nums[i]) - i) &lt;= k) &#123; return true &#125; else &#123; hash.set(nums[i], i) &#125; &#125; else &#123; hash.set(nums[i], i) &#125; &#125; return false&#125;; 官方解题的思路 用哈希表来维护这个k大小的滑动窗口。 遍历数组，对于每个元素做以下操作： 在哈希表中搜索当前元素，如果找到了就返回 true。 在哈希表中插入当前元素。 如果当前哈希表的大小超过了 k，删除哈希表中最旧的元素。 返回 false。 时间复杂度：O(n)，n为数组长度 123456789101112131415161718/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; k * @return &#123;boolean&#125; */var containsNearbyDuplicate = function(nums, k) &#123; const set = new Set(); for(let i = 0; i &lt; nums.length; i++) &#123; if(set.has(nums[i])) &#123; return true; &#125; set.add(nums[i]); if(set.size &gt; k) &#123; set.delete(nums[i - k]); &#125; &#125; return false;&#125;;","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"简单","slug":"简单","permalink":"http://yoursite.com/tags/简单/"},{"name":"哈希表","slug":"哈希表","permalink":"http://yoursite.com/tags/哈希表/"}]},{"title":"leetcdoe.209.长度最小的子数组-二分方法未写","date":"2020-07-19T06:10:32.000Z","path":"2020/07/19/leetcode-209-长度最小的子数组-二分方法未写/","text":"题目描述给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组。如果不存在符合条件的连续子数组，返回 0。 示例: 输入: s = 7, nums = [2,3,1,2,4,3]输出: 2解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组。进阶: 如果你已经完成了O(n) 时间复杂度的解法, 请尝试 O(n log n) 时间复杂度的解法。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/minimum-size-subarray-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 标签 数组 双指针 二分查找 解法一：双指针，滑动窗口12345678910111213141516171819202122232425262728/** * @param &#123;number&#125; s * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var minSubArrayLen = function(s, nums) &#123; let left = 0 let right = -1 // 滑动窗口 nums[left...right] let sum = 0 // 记录找到的最大值 let res = nums.length + 1 // 记录连续数组的长度 while (left &lt; nums.length) &#123; if (right + 1 &lt; nums.length &amp;&amp; sum &lt; s) &#123; right++ sum += nums[right] &#125; else &#123; sum -= nums[left] left++; &#125; if (sum &gt;= s) &#123; res = Math.min(res, right - left + 1) &#125; &#125; if (res === nums.length+1) &#123; return 0 // 没有找到答案返回0 &#125; return res &#125;;","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"双指针","slug":"双指针","permalink":"http://yoursite.com/tags/双指针/"},{"name":"中等","slug":"中等","permalink":"http://yoursite.com/tags/中等/"},{"name":"二分查找","slug":"二分查找","permalink":"http://yoursite.com/tags/二分查找/"}]},{"title":"leetcode.205.同构字符串","date":"2020-07-19T06:10:22.000Z","path":"2020/07/19/leetcode-205-同构字符串/","text":"题目描述给定两个字符串 s 和 t，判断它们是否是同构的。 如果 s 中的字符可以被替换得到 t ，那么这两个字符串是同构的。 所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。 示例 1:12输入: s = &quot;egg&quot;, t = &quot;add&quot;输出: true 示例 2:12输入: s = &quot;foo&quot;, t = &quot;bar&quot;输出: false 示例 3:12输入: s = &quot;paper&quot;, t = &quot;title&quot;输出: true 说明:你可以假设 s 和 t 具有相同的长度。 标签 哈希表 https://leetcode-cn.com/problems/isomorphic-strings/ 解法一：indexOf会返回指定字符串值在字符串中首次出现的位置 s 和 t 具有相同的长度 所以遍历一次，比较每个位置是否同构 如果遍历当前字符串是未出现过的，那两边indexOf肯定是当前i 如果遍历当前字符串是以前出现过的，那两边indexOf会拿到首次相同字串符的下标，值也应该一样 时间复杂度：两个字符串的indexOf加上一次遍历O(n^2) 123456789101112/** * @param &#123;string&#125; s * @param &#123;string&#125; t * @return &#123;boolean&#125; */var isIsomorphic = function(s, t) &#123; for(let i = 0; i &lt; s.length; i++) &#123; if(s.indexOf(s[i]) != t.indexOf(t[i])) return false &#125; return true&#125;; 解法二：哈希映射 两个字符串相互映射。 遇到重复的子字符串，判断两个哈希表里对应的映射是否正确。 12345678910111213141516171819202122/** * @param &#123;string&#125; s * @param &#123;string&#125; t * @return &#123;boolean&#125; */var isIsomorphic = function(s, t) &#123; let hash1 = new Map() let hash2 = new Map() for(let i = 0; i &lt; s.length; i++) &#123; let S = s[i] let T = t[i] if(hash1.has(S)) &#123; if(hash1.get(S) !== T) return false &#125; else if(hash2.has(T)) &#123; if(hash2.get(T) !== S) return false &#125; else &#123; hash1.set(S, T) hash2.set(T, S) &#125; &#125; return true&#125;;","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"简单","slug":"简单","permalink":"http://yoursite.com/tags/简单/"},{"name":"哈希表","slug":"哈希表","permalink":"http://yoursite.com/tags/哈希表/"}]},{"title":"leetcode.202.快乐数","date":"2020-07-19T06:10:15.000Z","path":"2020/07/19/leetcode-202-快乐数/","text":"题目描述编写一个算法来判断一个数是不是“快乐数”。 一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。 示例:1234567输入: 19输出: true解释: 12 + 92 = 8282 + 22 = 6862 + 82 = 10012 + 02 + 02 = 1 标签 哈希表 数学 https://leetcode-cn.com/problems/happy-number/ 一、题目给出的计算方式获取每个位置上的数字的平方和，然后重复这个过程 二、依据计算方式，得到结果范围 每个位置上的数字范围：0~9 于1位数，平方和范围：1~81 对于2位数，平方和范围：1~162 对于3位数，平方和范围：1~243 整数最大位数是10位数(最大的整数2147483647)，那么平方和范围：1~810 可以看出，平方和总会回归到3位数，并进入 1~243 这个数字范围内 三、思路1：依据“快乐集合”和“不快乐集合”来判断 既然所有整数，最终都会落到 1~243这个范围 那么这些数字，肯定有的可以得到1，有的得不到，所以这些数字就可以分成两个集合，快乐集合 和 不快乐集合 所以，如果一个整数，计算结果落在其中的一个集合，那么这个整数就是“快乐”或者“不快乐”的 四、思路2：依据是否循环来判断 既然平方和结果范围是有限的，即1~243，那么只要可以不断计算下去，就必然是循环的 程序可以检测到这种循环，进而判断整数非快乐数 五、时间复杂度分析 既然所有整数的平方和都会落在 1~243 这个范围内，那么就说明这个循环判定结果一定是有循环次数上限的，所以它是一个常数复杂度，即O(1) 12345678910111213141516171819/** * @param &#123;number&#125; n * @return &#123;boolean&#125; */var isHappy = function(n) &#123; if(n == 1 || n == 7) &#123; return true; &#125; if (n &lt; 10) &#123; return false; &#125; let sum = 0; while(n &gt;= 1) &#123; let num = n%10; n = Math.floor(n/10); sum += num*num; &#125; return isHappy(sum);&#125;;","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"简单","slug":"简单","permalink":"http://yoursite.com/tags/简单/"},{"name":"哈希表","slug":"哈希表","permalink":"http://yoursite.com/tags/哈希表/"},{"name":"数学","slug":"数学","permalink":"http://yoursite.com/tags/数学/"}]},{"title":"leetcode.167.两数之和II-输入有序数组","date":"2020-07-19T06:10:04.000Z","path":"2020/07/19/leetcode-167-两数之和II-输入有序数组/","text":"题目描述给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。 函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。 说明:12返回的下标值（index1 和 index2）不是从零开始的。你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。 示例:123输入: numbers = [2, 7, 11, 15], target = 9输出: [1,2]解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 标签 数组 双指针 二分查找 解法一：双循环，暴力时间复杂度：O(n^2) 这个很简单，遍历每个元素x，并查找是否存在一个值与target - x 相等的目标元素。1234567891011121314151617/** * @param &#123;number[]&#125; numbers * @param &#123;number&#125; target * @return &#123;number[]&#125; */var twoSum = function(numbers, target) &#123; let res = [] for ( let i = 0; i &lt; numbers.length; i++ ) &#123; for ( let j = i+1; j &lt; numbers.length; j++ ) &#123; if ( numbers[ i ] + numbers[ j ] === target ) &#123; i++, j++ res = [i,j] return res &#125; &#125; &#125;&#125;; 解法二：hash表时间复杂度：O(n)123x + y = targety = target - xx + (target - x) = target 套入题目的例子，遍历数组，数组遍历的当前值为numbers[i]，那么 y 应该是 target - numbers[i]。所以，只要在遍历的时候确定target - numbers[i]在数组里有，返回对应下标。 hash表方法有两次哈希表方法和一次哈希表方法。 两次hash表方法，在第一次迭代中，我们将每个元素的值和它的索引添加到表中。然后，在第二次迭代中，我们将检查每个元素所对应的目标元素（target−numbers[i]）是否存在于表中。 一次hash表方法，下面代码所示。123456789101112var twoSum = function(numbers, target) &#123; let map = new Map() for(let i = 0; i &lt; numbers.length; i ++) &#123; if(map.has(target - numbers[i])) &#123; return [map.get(target - numbers[i]) + 1, i + 1] &#125; map.set(numbers[i], i) &#125;&#125;; 解法三：双向指针由于数组是有序的，只需要双指针即可。一个left指针，一个right指针， 如果 left + right 值大于 target 则 right左移动， 否则 left 右移。 如果数组无序，需要先排序。1234567891011121314var twoSum = function(numbers, target) &#123; let left = 0; let right = numbers.length while(left &lt; right) &#123; if(numbers[left] + numbers[right] === target) &#123; return [left + 1, right + 1] &#125; else if(numbers[left] + numbers[right] &lt; target) &#123; left ++ &#125; else &#123; right -- &#125; &#125;&#125;; 解法四：二分查找时间复杂度：O(n log n) x + y = target, y = target - x 遍历 numbers , 利用二分查找找 target - numbers[i] 注意题目要求，其中 index1 必须小于 index2，而且你不可以重复使用相同的元素。 123456789101112131415161718192021222324252627282930/** * @param &#123;number[]&#125; numbers * @param &#123;number&#125; target * @return &#123;number[]&#125; */ const NOT_FOUND = -1 var twoSum = function(numbers, target) &#123; for (let i = 0; i &lt; numbers.length; i++) &#123; let y = target - numbers[i] let res = binarySearch(numbers, y) if(res !== NOT_FOUND &amp;&amp; i !== res)&#123; return i &lt; res ? [i + 1, res + 1] : [res + 1, i + 1] &#125; &#125; &#125; const binarySearch = function(array, target) &#123; let low = 0 let high = array.length - 1 while (low &lt;= high) &#123; let mid = ~~((low + high) / 2) if (array[mid] &lt; target) &#123; low = mid + 1 &#125; else if (array[mid] &gt; target) &#123; high = mid - 1 &#125; else &#123; return mid &#125; &#125; return NOT_FOUND &#125;","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"双指针","slug":"双指针","permalink":"http://yoursite.com/tags/双指针/"},{"name":"简单","slug":"简单","permalink":"http://yoursite.com/tags/简单/"},{"name":"二分查找","slug":"二分查找","permalink":"http://yoursite.com/tags/二分查找/"}]},{"title":"leetcode.155.最小栈","date":"2020-07-19T06:09:48.000Z","path":"2020/07/19/leetcode-155-最小栈/","text":"题目描述设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。1234push(x) -- 将元素 x 推入栈中。pop() -- 删除栈顶的元素。top() -- 获取栈顶元素。getMin() -- 检索栈中的最小元素。 示例:12345678MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); --&gt; 返回 -3.minStack.pop();minStack.top(); --&gt; 返回 0.minStack.getMin(); --&gt; 返回 -2. 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/min-stack著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 标签 栈 设计 解题思路push，pop，top 操作都是正常的栈操作。关键是在常数时间内检索到最小元素的栈。 要在常数时间内检索，常规做法是以空间换时间，一般使用辅助栈解决。 设一个临时栈 数据入栈时，临时栈为空，必须放入新元素 数据入栈时，临时栈不为空，要判断新元素是否小于等于临时栈顶。符合条件放入临时栈。 数据出栈时，判断元素是否等于临时栈栈顶元素。符合条件临时栈栈顶出栈。 解题方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * initialize your data structure here. */var MinStack = function() &#123; this.stack = [] this.tempStack = []&#125;;/** * @param &#123;number&#125; x * @return &#123;void&#125; */MinStack.prototype.push = function(x) &#123; this.stack.push(x) if(this.tempStack.length) &#123; this.tempStack[this.tempStack.length - 1] &lt; x ? '' : this.tempStack.push(x) &#125; else &#123; this.tempStack.push(x) &#125;&#125;;/** * @return &#123;void&#125; */MinStack.prototype.pop = function() &#123; let pop = this.stack.pop() if(pop == this.tempStack[this.tempStack.length - 1]) &#123; this.tempStack.pop() &#125;&#125;;/** * @return &#123;number&#125; */MinStack.prototype.top = function() &#123; return this.stack[this.stack.length - 1]&#125;;/** * @return &#123;number&#125; */MinStack.prototype.getMin = function() &#123; return this.tempStack[this.tempStack.length - 1]&#125;;/** * Your MinStack object will be instantiated and called as such: * var obj = new MinStack() * obj.push(x) * obj.pop() * var param_3 = obj.top() * var param_4 = obj.getMin() */","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"栈","slug":"栈","permalink":"http://yoursite.com/tags/栈/"},{"name":"简单","slug":"简单","permalink":"http://yoursite.com/tags/简单/"},{"name":"设计","slug":"设计","permalink":"http://yoursite.com/tags/设计/"}]},{"title":"leetcode.125.验证回文串","date":"2020-07-19T06:09:37.000Z","path":"2020/07/19/leetcode-125-验证回文串/","text":"题目描述给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 说明：本题中，我们将空字符串定义为有效的回文串。 示例 1:12输入: &quot;A man, a plan, a canal: Panama&quot;输出: true 示例 2:12输入: &quot;race a car&quot;输出: false 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/valid-palindrome著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 标签 双指针 字符串 解题思路 处理字符串，只考虑字母和数字字符，忽略字母的大小写 用对撞指针，递归查看首尾是否一致即是否回文串解题方法1234567891011121314151617181920/** * @param &#123;string&#125; s * @return &#123;boolean&#125; */var isPalindrome = function(s) &#123; // s = s.replace(/[^\\w]/g, '').toLowerCase() // 题目要求只考虑字母和数字字符，所以上面的写法也没啥问题 s = s.replace(/[^0-9a-zA-Z]/g, '').toLowerCase() let left = 0; let right = s.length - 1; while(left &lt; right) &#123; if(s[left] != s[right]) &#123; return false &#125; left++ right-- &#125; return true&#125;;","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"字符串","slug":"字符串","permalink":"http://yoursite.com/tags/字符串/"},{"name":"双指针","slug":"双指针","permalink":"http://yoursite.com/tags/双指针/"},{"name":"简单","slug":"简单","permalink":"http://yoursite.com/tags/简单/"}]},{"title":"leetcode.118.杨辉三角","date":"2020-07-19T06:09:30.000Z","path":"2020/07/19/leetcode-118-杨辉三角/","text":"题目描述给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。 在杨辉三角中，每个数是它左上方和右上方的数的和。 示例:123456789输入: 5输出:[ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/pascals-triangle著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 标签 数组 解题思路是在递归的卡片里看到的这题，所以先用递归解决了 终止条件，结果的 length 大于等于 numRows 返回值，每个二维数据的子数组 拆分的子问题，每个子数组的长度为当前行数，每个子数组里的值为它左上方和右上方的数的和，上方就是行数 - 1，左边就是当前子数组的值下标-1，右边就是下标+1，判断如果左上或者右上不存在，则为0 解题方法1234567891011121314151617181920212223var generate = function(numRows) &#123; let res = [] return sub(0, numRows, res)&#125;var sub = function(row, numRows, arr) &#123; let temp = [] if (row &lt; numRows) &#123; for (let i = 0; i &lt;= row; i++) &#123; if (row === 0) &#123; temp.push(1) &#125; else &#123; let left = i-1 &gt;= 0 ? arr[row-1][i-1] : 0 let right = i &lt; arr[row-1].length ? arr[row-1][i] : 0 temp.push(left+right) &#125; &#125; arr.push(temp) sub(++row, numRows, arr) return arr &#125;&#125;","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"简单","slug":"简单","permalink":"http://yoursite.com/tags/简单/"}]},{"title":"88.未完成，占坑","date":"2020-07-19T06:09:23.000Z","path":"2020/07/19/leetcode-88-未完成，占坑/","text":"题目描述给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。 说明:12初始化 nums1 和 nums2 的元素数量分别为 m 和 n。你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。 示例:12345输入:nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6], n = 3输出: [1,2,2,3,5,6] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/merge-sorted-array著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 标签 双指针 数组 解题思路解法一：唔。没学算法的解法。没啥用的。 时间复杂度较差，为O((n+m)log(n+m))123456789101112131415/** * @param &#123;number[]&#125; nums1 * @param &#123;number&#125; m * @param &#123;number[]&#125; nums2 * @param &#123;number&#125; n * @return &#123;void&#125; Do not return anything, modify nums1 in-place instead. */var merge = function(nums1, m, nums2, n) &#123; nums1.splice(m,nums1.length) nums2.splice(n,nums2.length) nums1.push(...nums2) nums1.sort((a,b) =&gt; &#123; return a - b &#125;)&#125;;","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]},{"title":"leetcode.80.删除排序数组中的重复项II","date":"2020-07-19T06:09:08.000Z","path":"2020/07/19/leetcode-80-删除排序数组中的重复项II/","text":"题目描述给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例 1:12345给定 nums = [1,1,1,2,2,3],函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。你不需要考虑数组中超出新长度后面的元素。 示例 2:12345给定 nums = [0,0,1,1,1,1,2,3,3],函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。你不需要考虑数组中超出新长度后面的元素。 说明:123为什么返回数值是整数，但输出的答案是数组呢?请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下:12345678// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 标签 双指针 数组 解题思路原地算法，就是不依赖额外的资源或者依赖少数的额外资源，仅依靠输出来覆盖输入的一种算法操作。 在不复制数组的情况下从数组中删除元素的一些提示： 尝试双指针法。 你是否使用“元素顺序可以更改”这一属性？ 当要删除的元素很少时会发生什么？ 解法一：数组api定义 nums[0…i] 满足每个元素最多出现两次，遍历整个数列不断的维护这个定义。 1234567891011121314/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var removeDuplicates = function(nums) &#123; let i = 0 while (i &lt; nums.length) &#123; if (nums[i] === nums[i - 2]) &#123; nums.splice(i, 1) &#125; else &#123; i++ &#125; &#125;&#125;; 解法二：双指针维护两个指针， 慢指针 p1 初始为 0 ，快指针 p2 初始为 1 如果快指针的后一位 (p2 + 1) 和前一位( p1 )都相同，那说明该元素出现三次。 出现三次把快指针 p2 下元素原地删除，快指针不变，继续比较 如果快指针和慢指针不相同，说明之前的数字都是最多出现两次的，把慢指针 p1 改为当前不同的数字下标，也就是快指针 p2 12345678910111213141516171819/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var removeDuplicates = function(nums) &#123; let p1 = 0 let p2 = 1 while (p2 &lt; nums.length) &#123; if(nums[p2] == nums[p1] &amp;&amp; nums[p2 + 1] == nums[p1]) &#123; nums.splice(p2, 1) &#125; else if(nums[p2] !== nums[p1])&#123; p1 = p2 p2++ &#125; else &#123; p2++ &#125; &#125;&#125;;","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"双指针","slug":"双指针","permalink":"http://yoursite.com/tags/双指针/"},{"name":"中等","slug":"中等","permalink":"http://yoursite.com/tags/中等/"}]},{"title":"leetcode.75.颜色分类","date":"2020-07-19T06:08:39.000Z","path":"2020/07/19/leetcode-75-颜色分类/","text":"题目描述给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。 此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。 注意:1不能使用代码库中的排序函数来解决这道题。 示例:12输入: [2,0,2,1,1,0]输出: [0,0,1,1,2,2] 进阶：12一个直观的解决方案是使用计数排序的两趟扫描算法。首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。 你能想出一个仅使用常数空间的一趟扫描算法吗？ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/sort-colors著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 标签 排序 双指针 数组 解题思路这道题的排序不是排[2,0,2,1,1,0]，这个只是抽象出来的。。 所以不止 sort 不能用，冒泡插入之类的排序也是不行的。 解法一：三指针时间复杂度O(n) 我们可以把数组分成三部分，前部（全部是0），中部（全部是1）和后部（全部是2）三个部分，每一个元素（红白蓝分别对应0、1、2）必属于其中之一。 将前部和后部各排在数组的前边和后边，中部自然就排好了。 我们用三个指针（p0, p2 和curr）来分别追踪0的最右边界，2的最左边界和当前考虑的元素。 本解法的思路是沿着数组移动 curr 指针，若nums[curr] = 0，则将其与 nums[p0]互换；若 nums[curr] = 2 ，则与 nums[p2]互换。 初始化0的最右边界：p0 = 0。在整个算法执行过程中 nums[idx &lt; p0] = 0. 初始化2的最左边界 ：p2 = n - 1。在整个算法执行过程中 nums[idx &gt; p2] = 2. 初始化当前考虑的元素序号 ：curr = 0. While curr &lt;= p2 : 若 nums[curr] = 0 ：交换第 curr个 和 第p0个 元素，并将指针都向右移。 若 nums[curr] = 2 ：交换第 curr个和第 p2个元素，并将 p2指针左移 。 若 nums[curr] = 1 ：将指针curr右移。 12345678910111213141516171819var sortColors = function(nums) &#123; if (nums.length &gt; 1) &#123; var p0 = 0, p2 = nums.length - 1, curr = 0 &#125; while (curr &lt;= p2) &#123; if (nums[curr] == 0) &#123; ;[nums[p0], nums[curr]] = [nums[curr], nums[p0]] p0++ curr++ &#125; else if (nums[curr] == 2) &#123; ;[nums[p2], nums[curr]] = [nums[curr], nums[p2]] p2-- &#125; else &#123; curr++ &#125; &#125;&#125; 解法二：计数排序时间复杂度O(n) 这样写也能过，但是这个不算是原地排序了。。 我们看一下计数排序是怎么运作 假设我们有[1,2,3,1,0,4]这六个数，这里面最大的值为4 那么我们创建一个长度为4+1的数组，每个元素默认为0。 这相当于选举排序，一共有6个投票箱，1就投1号箱，0就投入0号箱。 注意，这些箱本来就是已经排好序，并且箱的编号就是代表原数组的元素。当全部投完时，0号箱有1个，1号箱有2个，2号箱有1个，3号箱有1，4号箱有1个。 然后我们从这些箱的所有数依次出来，放到新数组，就神奇地排好序了。 计数排序没有对元素进行比较，只是利用了箱与元素的一一对应关系，根据箱已经排好序的先决条件，解决排序。 1234567891011121314151617181920212223/** * @param &#123;number[]&#125; nums * @return &#123;void&#125; Do not return anything, modify nums in-place instead. */var sortColors = function(nums) &#123; let stackLength = Math.max(...nums) // 获取数组里最大值 let countArr = Array(stackLength + 1).fill(0) // 创建长度为最大值+1的临时数组，并将元素设为0 for(let i = 0; i &lt; nums.length; i ++)&#123; // 遍历数组，在临时数组对应 key 上计数 countArr[nums[i]] += 1 &#125; nums.length = 0 // 因为题目要求原地排序 for(let i = 0; i &lt; countArr.length; i++) &#123; // 把计数数组按顺序放回原数组 while(countArr[i]) &#123; nums.push(i) countArr[i]-- &#125; &#125;&#125;;","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"双指针","slug":"双指针","permalink":"http://yoursite.com/tags/双指针/"},{"name":"中等","slug":"中等","permalink":"http://yoursite.com/tags/中等/"},{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/排序/"}]},{"title":"leetcode.50.Pow(x, n)","date":"2020-07-19T06:08:19.000Z","path":"2020/07/19/leetcode-50-Pow-x-n/","text":"题目描述实现 pow(x, n) ，即计算 x 的 n 次幂函数。 示例 1:12输入: 2.00000, 10输出: 1024.00000 示例 2:12输入: 2.10000, 3输出: 9.26100 示例 3:123输入: 2.00000, -2输出: 0.25000解释: 2-2 = 1/22 = 1/4 = 0.25 说明:12-100.0 &lt; x &lt; 100.0n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/powx-n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 标签 数学 二分查找 解法一：暴力法时间复杂度O(n) 模拟计算过程 如果 n &lt; 0 , n = -n, x = $\\frac{1}{x}$ 可以看示例3 不过这个会超时1234567891011121314151617/** * @param &#123;number&#125; x * @param &#123;number&#125; n * @return &#123;number&#125; */var myPow = function(x, n) &#123; if( n &lt; 0) &#123; x = 1 / x n = -n &#125; let res = 1 for(let i = 0; i &lt; n; i++) &#123; res *= x &#125; return res&#125;; 解法二：分治，二分时间复杂度O(n log n) 数学， 如果 n 为 0，那结果为 1 如果 n 为 1，那结果为 x 如果 n &lt; 0, n = -n, x = $\\frac{1}{x}$ 如果 n &gt; 0，正常计算 算法， 如果 n 是偶数位，那二分，结果就是 $x^\\frac{n}{2} \\times\\ x^\\frac{n}{2}$ 如果 n 是奇数位，那二分，结果就是 $x^\\frac{n}{2} \\times\\ x^\\frac{n}{2} \\times\\ x$ 比如 $2^4$ 就是 $2^2 \\times\\ 2^2$ ， $2^5$ 就是 $2^2 \\times\\ 2^2 \\times\\ 2$， 一直二分递归到 n 为 1 或者 0 1234567891011121314151617181920212223/** * @param &#123;number&#125; x * @param &#123;number&#125; n * @return &#123;number&#125; */var myPow = function(x, n) &#123; if(n === 0) &#123; return 1 &#125; if(n === 1) &#123; return x &#125; if(n &lt; 0) &#123; return myPow(1/x, -n) &#125; let half = ~~(n/2) let temp = myPow(x, half) if(n % 2 === 0) &#123; return temp * temp &#125; else &#123; return temp * temp * x &#125;&#125;;","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"中等","slug":"中等","permalink":"http://yoursite.com/tags/中等/"},{"name":"二分查找","slug":"二分查找","permalink":"http://yoursite.com/tags/二分查找/"},{"name":"数学","slug":"数学","permalink":"http://yoursite.com/tags/数学/"}]},{"title":"leetcode.49.字母异位词分组","date":"2020-07-19T06:07:52.000Z","path":"2020/07/19/leetcode-49-字母异位词分组/","text":"题目描述给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。 示例:1234567输入: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],输出:[ [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;], [&quot;nat&quot;,&quot;tan&quot;], [&quot;bat&quot;]] 说明： 所有输入均为小写字母。 不考虑答案输出的顺序。 标签 哈希表 字符串 https://leetcode-cn.com/problems/group-anagrams/ 解法一：哈希表当且仅当它们的排序字符串相等时，两个字符串是字母异位词。 维护一个哈希映射 ans : {String -&gt; List}，其中每个键 K 是一个排序字符串，每个值是初始输入的字符串列表，排序后等于 K。 时间复杂度：O(NKlogK)，其中 N 是 strs 的长度，而 K 是 strs 中字符串的最大长度。当我们遍历每个字符串时，外部循环具有的复杂度为 O(N)。然后，我们在 O(KlogK) 的时间内对每个字符串排序。 1234567891011121314151617181920/** * @param &#123;string[]&#125; strs * @return &#123;string[][]&#125; */var groupAnagrams = function(strs) &#123; let hash = new Map() for(let i = 0; i &lt; strs.length; i++) &#123; let str = strs[i].split('').sort().join() if(hash.has(str)) &#123; let temp = hash.get(str) temp.push(strs[i]) hash.set(str, temp) &#125; else &#123; hash.set(str, [strs[i]]) &#125; &#125; return [...hash.values()]&#125;; 解法二：利用数学设计键 算术基本定理，又称为正整数的唯一分解定理，即：每个大于1的自然数，要么本身就是质数，要么可以写为2个以上的质数的积，而且这些质因子按大小排列之后，写法仅有一种方式。 利用这个，我们把每个字符串都映射到一个正数上。 用一个数组存储质数 prime = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103]。 然后每个字符串的字符减去 ‘ a ‘ ，然后取到 prime 中对应的质数。把它们累乘。 例如 abc ，就对应 ‘a’ - ‘a’， ‘b’ - ‘a’， ‘c’ - ‘a’，即 0, 1, 2，也就是对应素数 2 3 5，然后相乘 2 3 5 = 30，就把 “abc” 映射到了 30。 相减时用 Unicode 编码。 和解法一的理论差不多，不过少了字符串的排序。 也就是用另外一种方式解决了哈希设计键。 时间复杂度 O(NK) 12345678910111213var groupAnagrams = function(strs) &#123; let res = &#123;&#125;; for(let i = 0; i &lt; strs.length; i++) &#123; const str = strs[i] const hash = str.split('').reduce((sum, s)=&gt;&#123; return sum * [3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103 ][s.charCodeAt(0) - 97] &#125;, 1) res[hash] ? res[hash].push(str) : res[hash] = [str] &#125; return Object.values(res)&#125;; 解法三：计数 首先初始化 key = “0#0#0#0#0#”，数字分别代表 abcde 出现的次数，# 用来分割。 这样的话，”abb” 就映射到了 “1#2#0#0#0”。 “cdc” 就映射到了 “0#0#2#1#0”。 “dcc” 就映射到了 “0#0#2#1#0”。 然后和其他解法一样，如果 key 一样，就把值映射到对应的 key 里。 时间复杂度：O(NK)。 123456789101112131415161718192021222324/** * @param &#123;string[]&#125; strs * @return &#123;string[][]&#125; */var groupAnagrams = function(strs) &#123; let hash = new Map() for(let i = 0; i &lt; strs.length; i++) &#123; let str = strs[i] let arr = Array(26).fill(0) for(let j = 0; j &lt; str.length; j++) &#123; arr[str.charCodeAt(j) - 97] ++ &#125; let hashKey = arr.join() if(hash.has(hashKey)) &#123; let temp = hash.get(hashKey) temp.push(str) hash.set(hashKey, temp) &#125; else &#123; hash.set(hashKey, [str]) &#125; &#125; return [...hash.values()]&#125;; 所有的方法基本上都是为哈希表设计合适的键 因为需要几个值同时对应同一个键 所以要找到一个合适键的规则","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"字符串","slug":"字符串","permalink":"http://yoursite.com/tags/字符串/"},{"name":"中等","slug":"中等","permalink":"http://yoursite.com/tags/中等/"},{"name":"哈希表","slug":"哈希表","permalink":"http://yoursite.com/tags/哈希表/"}]},{"title":"leetcode.36.有效的数独","date":"2020-07-19T06:06:50.000Z","path":"2020/07/19/leetcode-36-有效的数独/","text":"题目描述判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。 数字 1-9 在每一行只能出现一次。数字 1-9 在每一列只能出现一次。数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。 上图是一个部分填充的有效的数独。 数独部分空格内已填入了数字，空白格用 ‘.’ 表示。 示例 1:12345678910111213输入:[ [&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;], [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;], [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;], [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;], [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]输出: true 示例 2:12345678910111213输入:[ [&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;], [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;], [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;], [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;], [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]输出: false 解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。 说明:一个有效的数独（部分已被填充）不一定是可解的。只需要根据以上规则，验证已经填入的数字是否有效即可。给定数独序列只包含数字 1-9 和字符 ‘.’ 。给定数独永远是 9x9 形式的。 标签 哈希表 https://leetcode-cn.com/problems/valid-sudoku/ 方法一：一次迭代思路： 每一行、每一列、每一个小正方形都不能重复出现相同数字 用hash记录它的行，列和小正方形的值，有重复就false 可以用 (~~(i/3))*3 + ~~(j/3) 来确定小正方块的位置 时间复杂度：O(1)，因为我们只对 81 个单元格进行了一次迭代。 123456789101112131415161718192021222324252627282930313233343536/** * @param &#123;character[][]&#125; board * @return &#123;boolean&#125; */var isValidSudoku = function(board) &#123; let rows = new Map() let cols = new Map() let boxs = new Map() for(let i = 0; i &lt; board.length; i++) &#123; rows.set(`rows$&#123;i&#125;`, new Map()) cols.set(`cols$&#123;i&#125;`, new Map()) boxs.set(`boxs$&#123;i&#125;`, new Map()) &#125; for(let i = 0; i &lt; board.length; i++) &#123; for(let j = 0; j &lt; board[i].length; j++) &#123; if(board[i][j] == '.') continue let boxIndex = (~~(i/3))*3 + ~~(j/3) let row = rows.get(`rows$&#123;i&#125;`) let col = cols.get(`cols$&#123;j&#125;`) let box = boxs.get(`boxs$&#123;boxIndex&#125;`) if(row.has(board[i][j]) || col.has(board[i][j]) || box.has(board[i][j])) &#123; return false &#125; else &#123; row.set(board[i][j], 1) col.set(board[i][j], 1) box.set(board[i][j], 1) &#125; &#125; &#125; return true&#125;; 方法二：三次迭代一个简单的解决方案是遍历该 9 x 9 数独 三 次，以确保： 行中没有重复的数字。 列中没有重复的数字。 3 x 3 子数独内没有重复的数字。 这个没啥说的。 1234567891011121314151617181920212223242526272829303132333435363738/** * @param &#123;character[][]&#125; board * @return &#123;boolean&#125; */var isValidSudoku = function(board) &#123; for (let i = 0; i &lt; 9; i++) &#123; // 检查行重复项 let row = &#123;&#125;; for (let j = 0; j &lt; 9; j++) &#123; if (board[i][j] !== '.') &#123; if (row[board[i][j]]) return false; row[board[i][j]] = 1; &#125; &#125; &#125; for (let i = 0; i &lt; 9; i++) &#123; // 检查列重复项 let col = &#123;&#125;; for (let j = 0; j &lt; 9; j++) &#123; if (board[j][i] !== '.') &#123; if (col[board[j][i]]) return false; col[board[j][i]] = 1; &#125; &#125; &#125; for (let i = 0; i &lt; 9; i += 3) &#123; // 检查3*3宫格重复项 for (let j = 0; j &lt; 9; j += 3) &#123; let miniTable = &#123;&#125;; for (let m = i; m &lt; i + 3; m++) &#123; for (let n = j; n &lt; j + 3; n++) &#123; if (board[m][n] !== '.') &#123; if (miniTable[board[m][n]]) return false; miniTable[board[m][n]] = 1; &#125; &#125; &#125; &#125; &#125; return true;&#125;;","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"中等","slug":"中等","permalink":"http://yoursite.com/tags/中等/"},{"name":"哈希表","slug":"哈希表","permalink":"http://yoursite.com/tags/哈希表/"}]},{"title":"leetcode.27.移除元素","date":"2020-07-19T06:06:40.000Z","path":"2020/07/19/leetcode-27-移除元素/","text":"题目描述给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 示例 1:12345给定 nums = [3,2,2,3], val = 3,函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。 示例 2:1234567给定 nums = [0,1,2,2,3,0,4,2], val = 2,函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。 说明:123为什么返回数值是整数，但输出的答案是数组呢?请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下:12345678// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝int len = removeElement(nums, val);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/remove-element著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 标签 双指针 数组 解题思路原地算法，就是不依赖额外的资源或者依赖少数的额外资源，仅依靠输出来覆盖输入的一种算法操作。 在不复制数组的情况下从数组中删除元素的一些提示： 尝试双指针法。 你是否使用“元素顺序可以更改”这一属性？ 当要删除的元素很少时会发生什么？解法一：双指针 注意是原地算法，数组长度是会变动的，所以定义一个变量存储数组长度。12345678910111213141516171819/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; val * @return &#123;number&#125; */var removeElement = function(nums, val) &#123; let temp = 0 let len = nums.length for(let i = 0; i &lt; len; i++) &#123; if(nums[temp]=== val) &#123; nums.splice(temp, 1) &#125; else &#123; temp++ &#125; &#125; return nums.length&#125;; 上面的代码等于 val 的值有几个就要多做几次无意义的循环。 优化下代码。 当我们遇到 nums[i] = val 时，我们可以将当前元素与最后一个元素进行交换，并释放最后一个元素。这实际上使数组的大小减少了 1。 请注意，被交换的最后一个元素可能是您想要移除的值。但是不要担心，在下一次迭代中，我们仍然会检查这个元素。 12345678910111213141516171819/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; val * @return &#123;number&#125; */var removeElement = function(nums, val) &#123; let i = 0 let len = nums.length while(i &lt; len) &#123; if(nums[i] == val) &#123; nums[i] = nums[len - 1] len-- &#125; else &#123; i++ &#125; &#125; return len&#125;;","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"双指针","slug":"双指针","permalink":"http://yoursite.com/tags/双指针/"},{"name":"简单","slug":"简单","permalink":"http://yoursite.com/tags/简单/"}]},{"title":"leetcode.26.删除排序数组中的重复项","date":"2020-07-19T06:06:09.000Z","path":"2020/07/19/leetcode-26-删除排序数组中的重复项/","text":"题目描述给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例 1:12345给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2:12345给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。 说明:123为什么返回数值是整数，但输出的答案是数组呢?请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下:12345678// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 标签 双指针 数组 解题思路原地算法，就是不依赖额外的资源或者依赖少数的额外资源，仅依靠输出来覆盖输入的一种算法操作。 在不复制数组的情况下从数组中删除元素的一些提示： 尝试双指针法。 你是否使用“元素顺序可以更改”这一属性？ 当要删除的元素很少时会发生什么？解法一：双指针 注意是原地算法，数组长度是会变动的，所以定义一个变量存储数组长度。12345678910111213141516/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var removeDuplicates = function(nums) &#123; const length = nums.length if(length == 0) return 0 let slow = 0 for(let fast = 1; fast &lt; length; fast++) &#123; if(nums[slow] !== nums[fast]) &#123; slow++ nums[slow] = nums[fast] &#125; &#125; return slow + 1&#125;; 也可以看下 27. 移除元素 的写法，基本一样。","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"双指针","slug":"双指针","permalink":"http://yoursite.com/tags/双指针/"},{"name":"简单","slug":"简单","permalink":"http://yoursite.com/tags/简单/"}]},{"title":"leetcode.24.两两交换链表中的节点","date":"2020-07-19T06:05:55.000Z","path":"2020/07/19/leetcode-24-两两交换链表中的节点/","text":"题目描述给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 示例:1给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3. 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/swap-nodes-in-pairs著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 标签 链表 解题思路这道题递归和非递归其实差不多。 先拆分子问题， 要把 head 和 head.next 交换，也就是相邻的节点交换 交换之后的 head.next.next 要指向下一对交换节点的 head 节点 然后递归直到 head 或者 head.next 为 null，也就是不够两个节点进行交换 要注意递归时传入下一对交换节点的 head 节点要传哪个，1234567891011121314151617181920/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; head * @return &#123;ListNode&#125; */var swapPairs = function(head) &#123; if(!head || !head.next) &#123; return head &#125; let tempHead = head.next head.next = swapPairs(head.next.next) tempHead.next = head return tempHead&#125;; 非递归写法 12345678910111213var swapPairs = function(head) &#123; let tempHead = new ListNode(0) tempHead.next = head let prev = tempHead while(prev.next &amp;&amp; prev.next.next) &#123; let a = prev.next let b = a.next prev.next = a.next a.next = b.next prev = b.next = a &#125; return tempHead.next&#125;;","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"中等","slug":"中等","permalink":"http://yoursite.com/tags/中等/"},{"name":"链表","slug":"链表","permalink":"http://yoursite.com/tags/链表/"}]},{"title":"leetcode.20.有效的括号","date":"2020-07-19T05:54:45.000Z","path":"2020/07/19/leetcode-20-有效的括号/","text":"题目描述给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。 有效字符串需满足：123左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。注意空字符串可被认为是有效字符串。 示例 1:12输入: &quot;()&quot;输出: true 示例 2:12输入: &quot;()[]&#123;&#125;&quot;输出: true 示例 3:12输入: &quot;(]&quot;输出: false 示例 4:12输入: &quot;([)]&quot;输出: false 示例 5:12输入: &quot;&#123;[]&#125;&quot;输出: true 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/valid-parentheses著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 标签 栈 字符串 解题思路 如果括号数量为奇数，肯定是错误的 如果括号数量为偶数，使用栈，遍历输入字符串 如果当前字符为左半边括号时，肯定是正确的，将其压入栈中 如果遇到右半边括号时，右半边括号与栈顶的左半括号不匹配，返回错误 如果匹配，把匹配的左半括号弹出栈 图片来自： https://github.com/MisterBooo/LeetCodeAnimation 解法一1234567891011121314151617181920212223242526272829303132333435/** * @param &#123;string&#125; s * @return &#123;boolean&#125; */var isValid = function(s) &#123; let sArr = s.split('') let temp = [] let res = true if(sArr.length % 2 == 1) return false try &#123; sArr.forEach(item =&gt; &#123; if (item.match(/\\(|\\&#123;|\\[/)) &#123; temp.push(item) &#125; else &#123; if (item == ')' &amp;&amp; temp.pop() == '(') &#123; return &#125; else if (item == '&#125;' &amp;&amp; temp.pop() == '&#123;') &#123; return &#125; else if (item == ']' &amp;&amp; temp.pop() == '[') &#123; return &#125; else &#123; res = false throw new Error() // 如果为false，用try catch跳出循环 &#125; &#125; &#125;) &#125; catch (error) &#123;&#125; if (temp.length == 0 &amp;&amp; res) &#123; return true &#125; else &#123; return false &#125;&#125;; js没有现成的栈，用数组模拟可以用 try catch 跳出 forEach 循环 这道题写法可能各不相同，但解题逻辑只有这一种。 比如写法可以把每对括号存hash表里，然后匹配的时候用 key: value 匹配对应的括号 或者用for循环，跳出和return容易很多。1let hash = &#123; ')': '(', '&#125;': '&#123;', ']': '[' &#125; 扩展事实上，这类问题还可以进一步扩展，我们可以去解析类似HTML等标记语法， 比如检查XML标签是否闭合如何检查， 更进一步如果要你实现一个简单的XML的解析器，应该怎么实现？","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"栈","slug":"栈","permalink":"http://yoursite.com/tags/栈/"},{"name":"字符串","slug":"字符串","permalink":"http://yoursite.com/tags/字符串/"},{"name":"简单","slug":"简单","permalink":"http://yoursite.com/tags/简单/"}]},{"title":"leetcode.11.有效的括号","date":"2020-07-19T05:41:00.000Z","path":"2020/07/19/leetcode-11-有效的括号/","text":"题目描述给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且 n 的值至少为 2。 图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 示例:12输入: [1,8,6,2,5,4,8,3,7]输出: 49 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/container-with-most-water著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 标签 数组 双指针 解题思路设置对撞指针 left，right，每次选两指针中的短板向中间移动1格，并且更新面积最大值 res，直到 i == j 时返回 res。 至于为什么移动短的指针不会漏掉最优解，下面这个是大神写的正确性证明。 11题双指针正确性证明 下面这个可能容易理解点 原面积s = h(i) * w 如果移动 j, 有两种肩况 移动后 j’ 的高度比i 高, s’= h(i) * (w-l) &lt; s 移动后 j’ 的高度比i 低, s’= h(j’) * (w-l) &lt; s 两种情况下, 移动后的面积s 都会小于s所以可证， 只有移动较短边才有可能面积更大 解法一：双指针1234567891011121314151617181920/** * @param &#123;number[]&#125; height * @return &#123;number&#125; */var maxArea = function(height) &#123; let res = 0 let left = 0 let right = height.length - 1 while(left &lt; right) &#123; let h = Math.min(height[left], height[right]) let w = right - left res = Math.max(h * w, res) if(height[left] &lt; height[right]) &#123; left++ &#125; else &#123; right-- &#125; &#125; return res&#125;;","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"双指针","slug":"双指针","permalink":"http://yoursite.com/tags/双指针/"},{"name":"中等","slug":"中等","permalink":"http://yoursite.com/tags/中等/"}]},{"title":"Hello World","date":"2020-07-18T17:41:21.396Z","path":"2020/07/19/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]},{"title":"404","date":"2019-07-19T08:41:10.000Z","path":"2019/07/19/404/","text":"","tags":[]}]